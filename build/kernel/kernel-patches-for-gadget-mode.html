<html><head><title>[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</title><link
    rel=alternate
    title="Atom feed"
    href="../../new.atom"
    type="application/atom+xml"/><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link
    type=text/css
    rel=stylesheet
    media=screen,print
    href=../../216light.css?67afc352 /><link
    type=text/css
    rel=stylesheet
    media="screen and (prefers-color-scheme:dark)"
    href=../../216dark.css?67afc352 /></head><body><form
    action="../../"><pre><a
    href="../../?t=20210628143344"><b>linux-usb.vger.kernel.org archive mirror</b></a>
    <input
    name=q
    type=text /><input
    type=submit
    value=search /> <a
    href="../../_/text/help/">help</a> / <a
    href="../../_/text/color/">color</a> / <a
    id=mirror
    href="../../_/text/mirror/">mirror</a> / <a
    href="../../new.atom">Atom feed</a></pre></form><pre><a
    href=#ea15d1b956bb4d021019ecfe176f738e38de1c946
    id=ma15d1b956bb4d021019ecfe176f738e38de1c946>*</a> <b>[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</b>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      2021-06-27 14:18   ` <a
    href="#mdf9a72eef529aca328a560f9bb4d1ed0af2f5445">Alan Stern</a>
      2021-06-26 21:18 ` <a
    href="#ma4dcc8b46e33a8365a8dca614cab4b78501d241c">[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</a> Igor Kononenko
                       ` <a
    href=#ra4dcc8b46e33a8365a8dca614cab4b78501d241c>(4 subsequent siblings)</a>
      <a
    href=#ra15d1b956bb4d021019ecfe176f738e38de1c946>5 siblings, 1 reply; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/raw">raw</a>)
      To: Felipe Balbi, Greg Kroah-Hartman
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626211851">linux-usb</a>, <a
    href="../../../lkml/?t=20210626211851">linux-kernel</a>
    
    SCSI command handlers currently have an ambiguous return value. This
    return value may indicate the length of the data written to the response
    buffer and the command&#39;s processing status. Thus, the understanding of
    command handling may be implicit.
    
    After this patch, the output buffer&#39;s size will be set in the
    &#39;data_size_to_handle&#39; field of &#39;struct fsg_common&#39;, and the command
    handler&#39;s return value indicates only the processing status.
    
    Tested: By probing the USBGadget Mass-Storage on the YADRO VEGMAN
    BMC(AST2500) sample, each SCSI command was sent through HOST-&gt;BMC; the
    USBGadget MassStorage debug print showed all sent commands works
    properly.
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-2-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    href=#Z2e.:..:20210626211820.107310-2-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>drivers/usb/gadget/function/f_mass_storage.c</a> | 176 ++++++++++---------
     1 file <a href="#ea15d1b956bb4d021019ecfe176f738e38de1c946">changed</a>, 95 insertions(+), 81 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-2-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    id=Z2e.:..:20210626211820.107310-2-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>diff</a> --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
    index 4a4703634a2a..e9a7f87b4df3 100644
    --- a/drivers/usb/gadget/function/f_mass_storage.c
    +++ b/drivers/usb/gadget/function/f_mass_storage.c
    </span><span
    class="hunk">@@ -296,6 +296,7 @@ struct fsg_common {
    </span> 	enum data_direction	data_dir;
         u32			data_size;
         u32			data_size_from_cmnd;
    <span
    class="add">+	u32			data_size_to_handle;
    </span> 	u32			tag;
         u32			residue;
         u32			usb_amount_left;
    <span
    class="hunk">@@ -1066,7 +1067,8 @@ static int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 		memset(buf, 0, 36);
             buf[0] = TYPE_NO_LUN;	/* Unsupported, no device-type */
             buf[4] = 31;		/* Additional length */
    <span
    class="del">-		return 36;
    </span><span
    class="add">+		common-&gt;data_size_to_handle = 36;
    +		return 0;
    </span> 	}
     
         buf[0] = curlun-&gt;cdrom ? TYPE_ROM : TYPE_DISK;
    <span
    class="hunk">@@ -1083,7 +1085,8 @@ static int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 	else
             memcpy(buf + 8, common-&gt;inquiry_string,
                    sizeof(common-&gt;inquiry_string));
    <span
    class="del">-	return 36;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 36;
    +	return 0;
    </span> }
     
     static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1136,7 +1139,8 @@ static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 	buf[7] = 18 - 8;			/* Additional sense length */
         buf[12] = ASC(sd);
         buf[13] = ASCQ(sd);
    <span
    class="del">-	return 18;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 18;
    +	return 0;
    </span> }
     
     static int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1155,7 +1159,8 @@ static int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 	put_unaligned_be32(curlun-&gt;num_sectors - 1, &#38;buf[0]);
                             /* Max logical block */
         put_unaligned_be32(curlun-&gt;blksize, &#38;buf[4]);/* Block length */
    <span
    class="del">-	return 8;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 8;
    +	return 0;
    </span> }
     
     static int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1177,7 +1182,8 @@ static int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 	memset(buf, 0, 8);
         buf[0] = 0x01;		/* 2048 bytes of user data, rest is EC */
         store_cdrom_address(&#38;buf[4], msf, lba);
    <span
    class="del">-	return 8;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 8;
    +	return 0;
    </span> }
     
     static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1204,7 +1210,8 @@ static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 	buf[13] = 0x16;			/* Lead-out track is data */
         buf[14] = 0xAA;			/* Lead-out track number */
         store_cdrom_address(&#38;buf[16], msf, curlun-&gt;num_sectors);
    <span
    class="del">-	return 20;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 20;
    +	return 0;
    </span> }
     
     static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1290,7 +1297,8 @@ static int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 		buf0[0] = len - 1;
         else
             put_unaligned_be16(len - 2, buf0);
    <span
    class="del">-	return len;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = len;
    +	return 0;
    </span> }
     
     static int do_start_stop(struct fsg_common *common)
    <span
    class="hunk">@@ -1381,7 +1389,8 @@ static int do_read_format_capacities(struct fsg_common *common,
    </span> 						/* Number of blocks */
         put_unaligned_be32(curlun-&gt;blksize, &#38;buf[4]);/* Block length */
         buf[4] = 0x02;				/* Current capacity */
    <span
    class="del">-	return 12;
    </span><span
    class="add">+	common-&gt;data_size_to_handle = 12;
    +	return 0;
    </span> }
     
     static int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)
    <span
    class="hunk">@@ -1796,7 +1805,7 @@ static int do_scsi_command(struct fsg_common *common)
    </span> {
         struct fsg_buffhd	*bh;
         int			rc;
    <span
    class="del">-	int			reply = -EINVAL;
    </span><span
    class="add">+	int			status = -EINVAL;
    </span> 	int			i;
         static char		unknown[16];
     
    <span
    class="hunk">@@ -1813,104 +1822,107 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 	common-&gt;short_packet_received = 0;
     
         down_read(&#38;common-&gt;filesem);	/* We&#39;re using the backing file */
    <span
    class="add">+	/* flash all unhandled data */
    +	common-&gt;data_size_to_handle = 0;
    +
    </span> 	switch (common-&gt;cmnd[0]) {
     
         case INQUIRY:
             common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_TO_HOST,
    </span> 				      (1&lt;&lt;4), 0,
                           &#34;INQUIRY&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_inquiry(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_inquiry(common, bh);
    </span> 		break;
     
         case MODE_SELECT:
             common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_FROM_HOST,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_FROM_HOST,
    </span> 				      (1&lt;&lt;1) | (1&lt;&lt;4), 0,
                           &#34;MODE SELECT(6)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_mode_select(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_mode_select(common, bh);
    </span> 		break;
     
         case MODE_SELECT_10:
             common-&gt;data_size_from_cmnd =
                 get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_FROM_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_FROM_HOST,
    </span> 				      (1&lt;&lt;1) | (3&lt;&lt;7), 0,
                           &#34;MODE SELECT(10)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_mode_select(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_mode_select(common, bh);
    </span> 		break;
     
         case MODE_SENSE:
             common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_TO_HOST,
    </span> 				      (1&lt;&lt;1) | (1&lt;&lt;2) | (1&lt;&lt;4), 0,
                           &#34;MODE SENSE(6)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_mode_sense(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_mode_sense(common, bh);
    </span> 		break;
     
         case MODE_SENSE_10:
             common-&gt;data_size_from_cmnd =
                 get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_TO_HOST,
    </span> 				      (1&lt;&lt;1) | (1&lt;&lt;2) | (3&lt;&lt;7), 0,
                           &#34;MODE SENSE(10)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_mode_sense(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_mode_sense(common, bh);
    </span> 		break;
     
         case ALLOW_MEDIUM_REMOVAL:
             common-&gt;data_size_from_cmnd = 0;
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_NONE,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_NONE,
    </span> 				      (1&lt;&lt;4), 0,
                           &#34;PREVENT-ALLOW MEDIUM REMOVAL&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_prevent_allow(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_prevent_allow(common);
    </span> 		break;
     
         case READ_6:
             i = common-&gt;cmnd[4];
             common-&gt;data_size_from_cmnd = (i == 0) ? 256 : i;
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 6,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 6,
    </span> 				      DATA_DIR_TO_HOST,
                           (7&lt;&lt;1) | (1&lt;&lt;4), 1,
                           &#34;READ(6)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read(common);
    </span> 		break;
     
         case READ_10:
             common-&gt;data_size_from_cmnd =
                     get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 10,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 10,
    </span> 				      DATA_DIR_TO_HOST,
                           (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
                           &#34;READ(10)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read(common);
    </span> 		break;
     
         case READ_12:
             common-&gt;data_size_from_cmnd =
                     get_unaligned_be32(&#38;common-&gt;cmnd[6]);
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 12,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 12,
    </span> 				      DATA_DIR_TO_HOST,
                           (1&lt;&lt;1) | (0xf&lt;&lt;2) | (0xf&lt;&lt;6), 1,
                           &#34;READ(12)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read(common);
    </span> 		break;
     
         case READ_CAPACITY:
             common-&gt;data_size_from_cmnd = 8;
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_TO_HOST,
    </span> 				      (0xf&lt;&lt;2) | (1&lt;&lt;8), 1,
                           &#34;READ CAPACITY&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read_capacity(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read_capacity(common, bh);
    </span> 		break;
     
         case READ_HEADER:
    <span
    class="hunk">@@ -1918,11 +1930,11 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 			goto unknown_cmnd;
             common-&gt;data_size_from_cmnd =
                 get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_TO_HOST,
    </span> 				      (3&lt;&lt;7) | (0x1f&lt;&lt;1), 1,
                           &#34;READ HEADER&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read_header(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read_header(common, bh);
    </span> 		break;
     
         case READ_TOC:
    <span
    class="hunk">@@ -1930,53 +1942,53 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 			goto unknown_cmnd;
             common-&gt;data_size_from_cmnd =
                 get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_TO_HOST,
    </span> 				      (7&lt;&lt;6) | (1&lt;&lt;1), 1,
                           &#34;READ TOC&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read_toc(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read_toc(common, bh);
    </span> 		break;
     
         case READ_FORMAT_CAPACITIES:
             common-&gt;data_size_from_cmnd =
                 get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_TO_HOST,
    </span> 				      (3&lt;&lt;7), 1,
                           &#34;READ FORMAT CAPACITIES&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_read_format_capacities(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_read_format_capacities(common, bh);
    </span> 		break;
     
         case REQUEST_SENSE:
             common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_TO_HOST,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_TO_HOST,
    </span> 				      (1&lt;&lt;4), 0,
                           &#34;REQUEST SENSE&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_request_sense(common, bh);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_request_sense(common, bh);
    </span> 		break;
     
         case START_STOP:
             common-&gt;data_size_from_cmnd = 0;
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_NONE,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_NONE,
    </span> 				      (1&lt;&lt;1) | (1&lt;&lt;4), 0,
                           &#34;START-STOP UNIT&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_start_stop(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_start_stop(common);
    </span> 		break;
     
         case SYNCHRONIZE_CACHE:
             common-&gt;data_size_from_cmnd = 0;
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_NONE,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_NONE,
    </span> 				      (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
                           &#34;SYNCHRONIZE CACHE&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_synchronize_cache(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_synchronize_cache(common);
    </span> 		break;
     
         case TEST_UNIT_READY:
             common-&gt;data_size_from_cmnd = 0;
    <span
    class="del">-		reply = check_command(common, 6, DATA_DIR_NONE,
    </span><span
    class="add">+		status = check_command(common, 6, DATA_DIR_NONE,
    </span> 				0, 1,
                     &#34;TEST UNIT READY&#34;);
             break;
    <span
    class="hunk">@@ -1987,44 +1999,44 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 	 */
         case VERIFY:
             common-&gt;data_size_from_cmnd = 0;
    <span
    class="del">-		reply = check_command(common, 10, DATA_DIR_NONE,
    </span><span
    class="add">+		status = check_command(common, 10, DATA_DIR_NONE,
    </span> 				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
                           &#34;VERIFY&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_verify(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_verify(common);
    </span> 		break;
     
         case WRITE_6:
             i = common-&gt;cmnd[4];
             common-&gt;data_size_from_cmnd = (i == 0) ? 256 : i;
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 6,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 6,
    </span> 				      DATA_DIR_FROM_HOST,
                           (7&lt;&lt;1) | (1&lt;&lt;4), 1,
                           &#34;WRITE(6)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_write(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_write(common);
    </span> 		break;
     
         case WRITE_10:
             common-&gt;data_size_from_cmnd =
                     get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 10,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 10,
    </span> 				      DATA_DIR_FROM_HOST,
                           (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
                           &#34;WRITE(10)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_write(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_write(common);
    </span> 		break;
     
         case WRITE_12:
             common-&gt;data_size_from_cmnd =
                     get_unaligned_be32(&#38;common-&gt;cmnd[6]);
    <span
    class="del">-		reply = check_command_size_in_blocks(common, 12,
    </span><span
    class="add">+		status = check_command_size_in_blocks(common, 12,
    </span> 				      DATA_DIR_FROM_HOST,
                           (1&lt;&lt;1) | (0xf&lt;&lt;2) | (0xf&lt;&lt;6), 1,
                           &#34;WRITE(12)&#34;);
    <span
    class="del">-		if (reply == 0)
    -			reply = do_write(common);
    </span><span
    class="add">+		if (status == 0)
    +			status = do_write(common);
    </span> 		break;
     
         /*
    <span
    class="hunk">@@ -2042,27 +2054,29 @@ static int do_scsi_command(struct fsg_common *common)
    </span> unknown_cmnd:
             common-&gt;data_size_from_cmnd = 0;
             sprintf(unknown, &#34;Unknown x%02x&#34;, common-&gt;cmnd[0]);
    <span
    class="del">-		reply = check_command(common, common-&gt;cmnd_size,
    </span><span
    class="add">+		status = check_command(common, common-&gt;cmnd_size,
    </span> 				      DATA_DIR_UNKNOWN, ~0, 0, unknown);
    <span
    class="del">-		if (reply == 0) {
    </span><span
    class="add">+		if (status == 0) {
    </span> 			common-&gt;curlun-&gt;sense_data = SS_INVALID_COMMAND;
    <span
    class="del">-			reply = -EINVAL;
    </span><span
    class="add">+			status = -EINVAL;
    </span> 		}
             break;
         }
         up_read(&#38;common-&gt;filesem);
     
    <span
    class="del">-	if (reply == -EINTR || signal_pending(current))
    </span><span
    class="add">+	if (status == -EINTR || signal_pending(current))
    </span> 		return -EINTR;
     
    <span
    class="del">-	/* Set up the single reply buffer for finish_reply() */
    -	if (reply == -EINVAL)
    -		reply = 0;		/* Error reply length */
    -	if (reply &gt;= 0 &#38;&#38; common-&gt;data_dir == DATA_DIR_TO_HOST) {
    -		reply = min((u32)reply, common-&gt;data_size_from_cmnd);
    -		bh-&gt;inreq-&gt;length = reply;
    </span><span
    class="add">+	/* Set up the single status buffer for finish_reply() */
    +	if (status == -EINVAL)
    +		status = 0;		/* Error reply length */
    +	if (status == 0 &#38;&#38; common-&gt;data_dir == DATA_DIR_TO_HOST) {
    +		common-&gt;data_size_to_handle =
    +			min_t(u32, common-&gt;data_size_to_handle,
    +			      common-&gt;data_size_from_cmnd);
    +		bh-&gt;inreq-&gt;length = common-&gt;data_size_to_handle;
    </span> 		bh-&gt;state = BUF_STATE_FULL;
    <span
    class="del">-		common-&gt;residue -= reply;
    </span><span
    class="add">+		common-&gt;residue -= common-&gt;data_size_to_handle;
    </span> 	}				/* Otherwise it&#39;s already set */
     
         return 0;
    -- 
    2.32.0
    
    
    <a
    href=#ma15d1b956bb4d021019ecfe176f738e38de1c946
    id=ea15d1b956bb4d021019ecfe176f738e38de1c946>^</a> <a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-2-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#ra15d1b956bb4d021019ecfe176f738e38de1c946>16+ messages in thread</a></pre><hr><pre><a
    href=#ea4dcc8b46e33a8365a8dca614cab4b78501d241c
    id=ma4dcc8b46e33a8365a8dca614cab4b78501d241c>*</a> <b>[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</b>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
      2021-06-26 21:18 ` <a
    href="#ma15d1b956bb4d021019ecfe176f738e38de1c946">[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</a> Igor Kononenko
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      2021-06-26 23:29   ` <a
    href="#maaed19c5d26b1f62307d2d9d1215506946eab6bb">kernel test robot</a>
      2021-06-27 14:23   ` <a
    href="#m4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6">Alan Stern</a>
      2021-06-26 21:18 ` <a
    href="#m992ff2558771731a4569b5f8b060a9e264f524d1">[PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</a> Igor Kononenko
                       ` <a
    href=#r992ff2558771731a4569b5f8b060a9e264f524d1>(3 subsequent siblings)</a>
      <a
    href=#ra4dcc8b46e33a8365a8dca614cab4b78501d241c>5 siblings, 2 replies; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/raw">raw</a>)
      To: Felipe Balbi, Greg Kroah-Hartman
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626211855">linux-usb</a>, <a
    href="../../../lkml/?t=20210626211855">linux-kernel</a>
    
    Implements a universal way to define SCSI commands and configure
    precheck handlers.
    
    Tested: By probing the USBGadget Mass-Storage on the YADRO VEGMAN
    BMC(AST2500) sample, each SCSI command was sent through HOST-&gt;BMC; the
    USBGadget MassStorage debug print showed all sent commands works
    properly.
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    href=#Z2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>drivers/usb/gadget/function/f_mass_storage.c</a> | 540 +++++++++++--------
     <a
    id=iZ2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.h
    href=#Z2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.h>drivers/usb/gadget/function/storage_common.h</a> |   5 +
     2 files <a href="#ea4dcc8b46e33a8365a8dca614cab4b78501d241c">changed</a>, 310 insertions(+), 235 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    id=Z2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>diff</a> --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
    index e9a7f87b4df3..c3fddee21b53 100644
    --- a/drivers/usb/gadget/function/f_mass_storage.c
    +++ b/drivers/usb/gadget/function/f_mass_storage.c
    </span><span
    class="hunk">@@ -237,6 +237,137 @@ static const char fsg_string_interface[] = &#34;Mass Storage&#34;;
    </span> #include &#34;storage_common.h&#34;
     #include &#34;f_mass_storage.h&#34;
     
    <span
    class="add">+
    +/*------------------------------------------------------------------------*/
    +
    +/**
    + * @brief The handler of incoming CDB command
    + * @param cmd		- SCSI command number
    + * @param callback	- The callback of handle the incoming command
    + */
    +#define CDB_REG_HANDLER(cmd, callback)                                         \
    +	.command = (cmd), .do_command = (callback),                            \
    +	.type = CDB_HANDLER_COMMON, .name = (#cmd)
    +
    +/**
    + * @brief The handler of incoming CDB command
    + * @param cmd		- SCSI command nubmer with fsg buffhd
    + * @param callback	- The callback of handle the incoming command
    + */
    +#define CDB_REG_HANDLER_BUFFHD(cmd, callback)                                  \
    +	.command = (cmd), .do_command_with_buffhd = (callback),                \
    +	.type = CDB_HANDLER_FSG_BUFFHD, .name = (#cmd)
    +
    +/**
    + * @see CDB_REG_CHECKER_DS
    + * @details Register CDB command without additional check handler.
    + */
    +#define CDB_REG_NO_CHECKER(cmd, si, dir, req)                                  \
    +	.command = (cmd), .direction = (dir), .size_index = (si),              \
    +	.medium_required = (req), .do_check_command = NULL,
    +
    +/**
    + * @brief Register the CDB command checker, which checks an incoming command
    + * by specified criteria.
    + * This validator will take care of the specified data size (DS)
    + *
    + * @param cmd	- SCSI command nubmer
    + * @param s		- CDB command size in bytes
    + * @param si	- The CDB command might have the recommended response size.
    + * This field indicates the size field index in the input CDB command
    + * buffer
    + * @param dir	- Direction of data transfer of requested CDB command
    + * @param mask  - Mask of relevant bytes in the input command buffer.
    + * The ordinal number of a bit in the mask indicates that a byte in the
    + * CDB command buffer might be present.
    + * If that ordinal number bit equals zero, only a zero value must be
    + * present in this original byte.
    + * @param req	- Indicates that medium MUST be present or might be optional
    + * @param ds	- If @param SI member is equal to @enum CDB_SIZE_MANUAL, than this
    + * field indicates the custom response buffer size
    + */
    +#define CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, ds)                     \
    +	.command = (cmd), .size = (s), .size_index = (si), .direction = (dir), \
    +	.valid_bytes_bitmask = (mask), .medium_required = (req),               \
    +	.data_size_manual = (ds), .do_check_command = &#38;check_command
    +
    +/**
    + * @see CDB_REG_CHECKER_DS
    + * @details The data size is zero.
    + * This macro can&#39;t be used with the @enum CDB_SIZE_MANUAL
    + */
    +#define CDB_REG_CHECKER(cmd, s, si, dir, mask, req)                            \
    +	CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, 0)
    +
    +/**
    + * @see CDB_REG_CHECKER_DS
    + * @details The checker which registried by this macros will validate the input
    + * data size in blocks.
    + * Block size specified by MSF interface type, in the curlun-&gt;blksize.
    + */
    +#define CDB_REG_CHECKER_BLK(cmd, s, si, dir, mask, req)                        \
    +	CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, 0),                     \
    +		.do_check_command = &#38;check_command_size_in_blocks
    +
    +/**
    + * @brief Field index of possible data length of output buffer size, which
    + * contains in the input CDB command buffer
    + */
    +enum cdb_data_size_field {
    +	CDB_SIZE_MANUAL = -2,
    +	CDB_NO_SIZE_FIELD = -1,
    +	CDB_SIZE_FIELD_4 = 4,
    +	CDB_SIZE_FIELD_6 = 6,
    +	CDB_SIZE_FIELD_7 = 7,
    +};
    +
    +/* Type of CDB command checker with associated data to check */
    +struct cdb_command_check {
    +	/* SCSI command number */
    +	u8 command;
    +	/* CDB command size */
    +	size_t size;
    +	/* Size field index in the input CDB command buffer */
    +	enum cdb_data_size_field size_index;
    +	/* CDB command data direction, @enum data_direction */
    +	u8 direction;
    +	/* Mask of expected meaningfull bytes in input CDB command buffer */
    +	u32 valid_bytes_bitmask;
    +	/* Is medium must be present or not */
    +	u8 medium_required;
    +	/* If data size is custom (the size_index is equal to CDB_SIZE_MANUAL),
    +	 * then this field indicates the output data size
    +	 */
    +	u8 data_size_manual;
    +	/* the CDB command checker */
    +	int (*do_check_command)(struct fsg_common *common, int size,
    +				enum data_direction direction,
    +				unsigned int mask, int needs_medium,
    +				const char *name);
    +};
    +
    +/* CDB command hundler metadata */
    +struct cdb_handler {
    +	/* SCSI command number */
    +	u8 command;
    +	/**
    +	 * @brief the CDB command hundler
    +	 * @param fsg_common	- FSG instance
    +	 */
    +	int (*do_command)(struct fsg_common *common);
    +	/**
    +	 * @brief The CDB command hundler with a fsg_buffhd specified
    +	 */
    +	int (*do_command_with_buffhd)(struct fsg_common *common,
    +				      struct fsg_buffhd *bufhd);
    +	/* CDB handler type to pick a relevant callback */
    +	enum { CDB_HANDLER_COMMON, CDB_HANDLER_FSG_BUFFHD } type;
    +	/* SCSI command ASCII name */
    +	char *name;
    +};
    +
    +/*------------------------------------------------------------------------*/
    +
    </span> /* Static strings, in UTF-8 (for simplicity we use only ASCII characters) */
     static struct usb_string		fsg_strings[] = {
         {FSG_STRING_INTERFACE,		fsg_string_interface},
    <span
    class="hunk">@@ -1801,6 +1932,97 @@ static int check_command_size_in_blocks(struct fsg_common *common,
    </span> 			mask, needs_medium, name);
     }
     
    <span
    class="add">+static struct cdb_command_check cdb_checker_table[] = {
    +	{ CDB_REG_CHECKER(INQUIRY, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
    +			  0x0010, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(MODE_SELECT, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
    +			  0x0012, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(MODE_SELECT_10, 10, CDB_SIZE_FIELD_7,
    +			  DATA_DIR_FROM_HOST, 0x0182, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(MODE_SENSE, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
    +			  0x0016, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(MODE_SENSE_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
    +			  0x186, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(ALLOW_MEDIUM_REMOVAL, 6, CDB_NO_SIZE_FIELD,
    +			  DATA_DIR_NONE, 0x0010, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
    +			      0x001E, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
    +			      0x01BE, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
    +			      0x03FE, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_DS(READ_CAPACITY, 10, CDB_SIZE_MANUAL,
    +			     DATA_DIR_TO_HOST, 0x011E, MEDIUM_REQUIRED, 8) },
    +	{ CDB_REG_CHECKER(READ_HEADER, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
    +			  0x01BE, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER(READ_TOC, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
    +			  0x03C7, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER(READ_FORMAT_CAPACITIES, 10, CDB_SIZE_FIELD_7,
    +			  DATA_DIR_TO_HOST, 0x0180, MEDIUM_REQUIRED) },
    +
    +	{ CDB_REG_CHECKER(REQUEST_SENSE, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
    +			  0x0010, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(START_STOP, 6, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
    +			  0x0012, MEDIUM_OPTIONAL) },
    +	{ CDB_REG_CHECKER(SYNCHRONIZE_CACHE, 10, CDB_NO_SIZE_FIELD,
    +			  DATA_DIR_NONE, 0x01BC, MEDIUM_REQUIRED) },
    +
    +	{ CDB_REG_CHECKER(TEST_UNIT_READY, 6, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
    +			  0x0000, MEDIUM_REQUIRED) },
    +
    +	{ CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
    +			      0x0000, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
    +			      0x001E, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_BLK(WRITE_10, 10, CDB_SIZE_FIELD_7,
    +			      DATA_DIR_FROM_HOST, 0x01BE, MEDIUM_REQUIRED) },
    +	{ CDB_REG_CHECKER_BLK(WRITE_12, 12, CDB_SIZE_FIELD_6,
    +			      DATA_DIR_FROM_HOST, 0x03FE, MEDIUM_REQUIRED) },
    +};
    +
    +static struct cdb_handler cdb_handlers_table[] = {
    +	{ CDB_REG_HANDLER_BUFFHD(INQUIRY, &#38;do_inquiry) },
    +	{ CDB_REG_HANDLER_BUFFHD(MODE_SELECT, &#38;do_mode_select) },
    +	{ CDB_REG_HANDLER_BUFFHD(MODE_SELECT_10, &#38;do_mode_select) },
    +	{ CDB_REG_HANDLER_BUFFHD(MODE_SENSE, &#38;do_mode_sense) },
    +	{ CDB_REG_HANDLER_BUFFHD(MODE_SENSE_10, &#38;do_mode_sense) },
    +	{ CDB_REG_HANDLER(ALLOW_MEDIUM_REMOVAL, &#38;do_prevent_allow) },
    +	{ CDB_REG_HANDLER(READ_6, &#38;do_read) },
    +	{ CDB_REG_HANDLER(READ_10, &#38;do_read) },
    +	{ CDB_REG_HANDLER(READ_12, &#38;do_read) },
    +	{ CDB_REG_HANDLER_BUFFHD(READ_CAPACITY, &#38;do_read_capacity) },
    +	{ CDB_REG_HANDLER_BUFFHD(READ_HEADER, &#38;do_read_header) },
    +	{ CDB_REG_HANDLER_BUFFHD(READ_TOC, &#38;do_read_toc) },
    +	{ CDB_REG_HANDLER_BUFFHD(READ_FORMAT_CAPACITIES, &#38;do_read_format_capacities) },
    +
    +	{ CDB_REG_HANDLER_BUFFHD(REQUEST_SENSE, &#38;do_request_sense) },
    +	{ CDB_REG_HANDLER(START_STOP, &#38;do_start_stop) },
    +	{ CDB_REG_HANDLER(SYNCHRONIZE_CACHE, &#38;do_synchronize_cache) },
    +	{ CDB_REG_HANDLER(TEST_UNIT_READY, NULL) },
    +
    +	/*
    +	 * Although optional, this command is used by MS-Windows.  We
    +	 * support a minimal version: BytChk must be 0.
    +	 */
    +
    +	{ CDB_REG_HANDLER(VERIFY, do_verify) },
    +	{ CDB_REG_HANDLER(WRITE_6, do_write) },
    +	{ CDB_REG_HANDLER(WRITE_10, do_write) },
    +	{ CDB_REG_HANDLER(WRITE_12, do_write) },
    +	/*
    +	 * Some mandatory commands that we recognize but don&#39;t implement.
    +	 * They don&#39;t mean much in this setting.  It&#39;s left as an exercise
    +	 * for anyone interested to implement RESERVE and RELEASE in terms
    +	 * of Posix locks.
    +	 *
    +	 * Commands:
    +	 *	FORMAT_UNIT
    +	 *	RELEASE
    +	 *	RESERVE
    +	 *	SEND_DIAGNOSTIC
    +	 */
    +};
    +
    </span> static int do_scsi_command(struct fsg_common *common)
     {
         struct fsg_buffhd	*bh;
    <span
    class="hunk">@@ -1811,6 +2033,14 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 
         dump_cdb(common);
     
    <span
    class="add">+	/* The size of both handlers and SCSI-checkers tables must be equal */
    +	if (WARN(ARRAY_SIZE(cdb_checker_table) !=
    +			 ARRAY_SIZE(cdb_handlers_table),
    +		 &#34;The checkers and handlers tables length are not matched!\n&#34;)) {
    +		pr_err(&#34;Invalid cdb handlers initialization.\n&#34;);
    +		return status;
    +	}
    +
    </span> 	/* Wait for the next buffer to become available for data or status */
         bh = common-&gt;next_buffhd_to_fill;
         common-&gt;next_buffhd_to_drain = bh;
    <span
    class="hunk">@@ -1825,243 +2055,84 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 	/* flash all unhandled data */
         common-&gt;data_size_to_handle = 0;
     
    <span
    class="del">-	switch (common-&gt;cmnd[0]) {
    </span><span
    class="add">+	for (i = 0; i &lt; ARRAY_SIZE(cdb_checker_table); ++i) {
    +		const struct cdb_command_check *curr_check =
    +			&#38;cdb_checker_table[i];
    +		const struct cdb_handler *curr_handler = &#38;cdb_handlers_table[i];
    </span> 
    <span
    class="del">-	case INQUIRY:
    -		common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    -		status = check_command(common, 6, DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;4), 0,
    -				      &#34;INQUIRY&#34;);
    -		if (status == 0)
    -			status = do_inquiry(common, bh);
    -		break;
    -
    -	case MODE_SELECT:
    -		common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    -		status = check_command(common, 6, DATA_DIR_FROM_HOST,
    -				      (1&lt;&lt;1) | (1&lt;&lt;4), 0,
    -				      &#34;MODE SELECT(6)&#34;);
    -		if (status == 0)
    -			status = do_mode_select(common, bh);
    -		break;
    -
    -	case MODE_SELECT_10:
    -		common-&gt;data_size_from_cmnd =
    -			get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command(common, 10, DATA_DIR_FROM_HOST,
    -				      (1&lt;&lt;1) | (3&lt;&lt;7), 0,
    -				      &#34;MODE SELECT(10)&#34;);
    -		if (status == 0)
    -			status = do_mode_select(common, bh);
    -		break;
    -
    -	case MODE_SENSE:
    -		common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    -		status = check_command(common, 6, DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;1) | (1&lt;&lt;2) | (1&lt;&lt;4), 0,
    -				      &#34;MODE SENSE(6)&#34;);
    -		if (status == 0)
    -			status = do_mode_sense(common, bh);
    -		break;
    -
    -	case MODE_SENSE_10:
    -		common-&gt;data_size_from_cmnd =
    -			get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command(common, 10, DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;1) | (1&lt;&lt;2) | (3&lt;&lt;7), 0,
    -				      &#34;MODE SENSE(10)&#34;);
    -		if (status == 0)
    -			status = do_mode_sense(common, bh);
    -		break;
    -
    -	case ALLOW_MEDIUM_REMOVAL:
    -		common-&gt;data_size_from_cmnd = 0;
    -		status = check_command(common, 6, DATA_DIR_NONE,
    -				      (1&lt;&lt;4), 0,
    -				      &#34;PREVENT-ALLOW MEDIUM REMOVAL&#34;);
    -		if (status == 0)
    -			status = do_prevent_allow(common);
    -		break;
    -
    -	case READ_6:
    -		i = common-&gt;cmnd[4];
    -		common-&gt;data_size_from_cmnd = (i == 0) ? 256 : i;
    -		status = check_command_size_in_blocks(common, 6,
    -				      DATA_DIR_TO_HOST,
    -				      (7&lt;&lt;1) | (1&lt;&lt;4), 1,
    -				      &#34;READ(6)&#34;);
    -		if (status == 0)
    -			status = do_read(common);
    -		break;
    -
    -	case READ_10:
    -		common-&gt;data_size_from_cmnd =
    -				get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command_size_in_blocks(common, 10,
    -				      DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
    -				      &#34;READ(10)&#34;);
    -		if (status == 0)
    -			status = do_read(common);
    -		break;
    -
    -	case READ_12:
    -		common-&gt;data_size_from_cmnd =
    -				get_unaligned_be32(&#38;common-&gt;cmnd[6]);
    -		status = check_command_size_in_blocks(common, 12,
    -				      DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (0xf&lt;&lt;6), 1,
    -				      &#34;READ(12)&#34;);
    -		if (status == 0)
    -			status = do_read(common);
    -		break;
    -
    -	case READ_CAPACITY:
    -		common-&gt;data_size_from_cmnd = 8;
    -		status = check_command(common, 10, DATA_DIR_TO_HOST,
    -				      (0xf&lt;&lt;2) | (1&lt;&lt;8), 1,
    -				      &#34;READ CAPACITY&#34;);
    -		if (status == 0)
    -			status = do_read_capacity(common, bh);
    -		break;
    -
    -	case READ_HEADER:
    -		if (!common-&gt;curlun || !common-&gt;curlun-&gt;cdrom)
    -			goto unknown_cmnd;
    -		common-&gt;data_size_from_cmnd =
    -			get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command(common, 10, DATA_DIR_TO_HOST,
    -				      (3&lt;&lt;7) | (0x1f&lt;&lt;1), 1,
    -				      &#34;READ HEADER&#34;);
    -		if (status == 0)
    -			status = do_read_header(common, bh);
    -		break;
    -
    -	case READ_TOC:
    -		if (!common-&gt;curlun || !common-&gt;curlun-&gt;cdrom)
    -			goto unknown_cmnd;
    -		common-&gt;data_size_from_cmnd =
    -			get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command(common, 10, DATA_DIR_TO_HOST,
    -				      (7&lt;&lt;6) | (1&lt;&lt;1), 1,
    -				      &#34;READ TOC&#34;);
    -		if (status == 0)
    -			status = do_read_toc(common, bh);
    -		break;
    -
    -	case READ_FORMAT_CAPACITIES:
    -		common-&gt;data_size_from_cmnd =
    -			get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command(common, 10, DATA_DIR_TO_HOST,
    -				      (3&lt;&lt;7), 1,
    -				      &#34;READ FORMAT CAPACITIES&#34;);
    -		if (status == 0)
    -			status = do_read_format_capacities(common, bh);
    -		break;
    -
    -	case REQUEST_SENSE:
    -		common-&gt;data_size_from_cmnd = common-&gt;cmnd[4];
    -		status = check_command(common, 6, DATA_DIR_TO_HOST,
    -				      (1&lt;&lt;4), 0,
    -				      &#34;REQUEST SENSE&#34;);
    -		if (status == 0)
    -			status = do_request_sense(common, bh);
    -		break;
    -
    -	case START_STOP:
    -		common-&gt;data_size_from_cmnd = 0;
    -		status = check_command(common, 6, DATA_DIR_NONE,
    -				      (1&lt;&lt;1) | (1&lt;&lt;4), 0,
    -				      &#34;START-STOP UNIT&#34;);
    -		if (status == 0)
    -			status = do_start_stop(common);
    -		break;
    -
    -	case SYNCHRONIZE_CACHE:
    -		common-&gt;data_size_from_cmnd = 0;
    -		status = check_command(common, 10, DATA_DIR_NONE,
    -				      (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
    -				      &#34;SYNCHRONIZE CACHE&#34;);
    -		if (status == 0)
    -			status = do_synchronize_cache(common);
    -		break;
    -
    -	case TEST_UNIT_READY:
    -		common-&gt;data_size_from_cmnd = 0;
    -		status = check_command(common, 6, DATA_DIR_NONE,
    -				0, 1,
    -				&#34;TEST UNIT READY&#34;);
    -		break;
    -
    -	/*
    -	 * Although optional, this command is used by MS-Windows.  We
    -	 * support a minimal version: BytChk must be 0.
    -	 */
    -	case VERIFY:
    -		common-&gt;data_size_from_cmnd = 0;
    -		status = check_command(common, 10, DATA_DIR_NONE,
    -				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
    -				      &#34;VERIFY&#34;);
    -		if (status == 0)
    -			status = do_verify(common);
    -		break;
    -
    -	case WRITE_6:
    -		i = common-&gt;cmnd[4];
    -		common-&gt;data_size_from_cmnd = (i == 0) ? 256 : i;
    -		status = check_command_size_in_blocks(common, 6,
    -				      DATA_DIR_FROM_HOST,
    -				      (7&lt;&lt;1) | (1&lt;&lt;4), 1,
    -				      &#34;WRITE(6)&#34;);
    -		if (status == 0)
    -			status = do_write(common);
    -		break;
    -
    -	case WRITE_10:
    -		common-&gt;data_size_from_cmnd =
    -				get_unaligned_be16(&#38;common-&gt;cmnd[7]);
    -		status = check_command_size_in_blocks(common, 10,
    -				      DATA_DIR_FROM_HOST,
    -				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (3&lt;&lt;7), 1,
    -				      &#34;WRITE(10)&#34;);
    -		if (status == 0)
    -			status = do_write(common);
    -		break;
    -
    -	case WRITE_12:
    -		common-&gt;data_size_from_cmnd =
    -				get_unaligned_be32(&#38;common-&gt;cmnd[6]);
    -		status = check_command_size_in_blocks(common, 12,
    -				      DATA_DIR_FROM_HOST,
    -				      (1&lt;&lt;1) | (0xf&lt;&lt;2) | (0xf&lt;&lt;6), 1,
    -				      &#34;WRITE(12)&#34;);
    -		if (status == 0)
    -			status = do_write(common);
    -		break;
    -
    -	/*
    -	 * Some mandatory commands that we recognize but don&#39;t implement.
    -	 * They don&#39;t mean much in this setting.  It&#39;s left as an exercise
    -	 * for anyone interested to implement RESERVE and RELEASE in terms
    -	 * of Posix locks.
    -	 */
    -	case FORMAT_UNIT:
    -	case RELEASE:
    -	case RESERVE:
    -	case SEND_DIAGNOSTIC:
    -
    -	default:
    -unknown_cmnd:
    -		common-&gt;data_size_from_cmnd = 0;
    -		sprintf(unknown, &#34;Unknown x%02x&#34;, common-&gt;cmnd[0]);
    -		status = check_command(common, common-&gt;cmnd_size,
    -				      DATA_DIR_UNKNOWN, ~0, 0, unknown);
    -		if (status == 0) {
    -			common-&gt;curlun-&gt;sense_data = SS_INVALID_COMMAND;
    -			status = -EINVAL;
    </span><span
    class="add">+		if (common-&gt;cmnd[0] != curr_check-&gt;command)
    +			continue;
    +		if (WARN(curr_check-&gt;command != curr_handler-&gt;command,
    +			 &#34;Invalid CDB handlers initialization. Command not matches\n&#34;)) {
    +			goto end;
    </span> 		}
    <span
    class="del">-		break;
    </span><span
    class="add">+
    +		// The command was matched. Go to processing
    +		switch (curr_check-&gt;size_index) {
    +		case CDB_NO_SIZE_FIELD:
    +			common-&gt;data_size_from_cmnd = 0;
    +			break;
    +		case CDB_SIZE_FIELD_4:
    +			common-&gt;data_size_from_cmnd =
    +				(common-&gt;cmnd[CDB_SIZE_FIELD_4] == 0) ?
    +					0xFF :
    +					common-&gt;cmnd[CDB_SIZE_FIELD_4];
    +			break;
    +		case CDB_SIZE_FIELD_6:
    +			common-&gt;data_size_from_cmnd =
    +				get_unaligned_be32(&#38;common-&gt;cmnd[CDB_SIZE_FIELD_6]);
    +			break;
    +		case CDB_SIZE_FIELD_7:
    +			common-&gt;data_size_from_cmnd =
    +				get_unaligned_be16(&#38;common-&gt;cmnd[CDB_SIZE_FIELD_7]);
    +			break;
    +		case CDB_SIZE_MANUAL:
    +			common-&gt;data_size_from_cmnd =
    +				curr_check-&gt;data_size_manual;
    +			break;
    +		default:
    +			// should never happen
    +			pr_err(&#34;error of get kind size field\n&#34;);
    +			goto end;
    +		}
    +
    +		if (curr_check-&gt;do_check_command) {
    +			status = curr_check-&gt;do_check_command(common,
    +				curr_check-&gt;size, curr_check-&gt;direction,
    +				curr_check-&gt;valid_bytes_bitmask,
    +				curr_check-&gt;medium_required,
    +				curr_handler-&gt;name);
    +		} else {
    +			DBG(common, &#34;SCSI command: %s\n&#34;, curr_handler-&gt;name);
    +			status = 0;
    +		}
    +
    +		if (status == 0) {
    +			if (curr_handler-&gt;type == CDB_HANDLER_COMMON &#38;&#38;
    +			    curr_handler-&gt;do_command) {
    +				status = curr_handler-&gt;do_command(common);
    +			} else if (curr_handler-&gt;type ==
    +					   CDB_HANDLER_FSG_BUFFHD &#38;&#38;
    +				   curr_handler-&gt;do_command_with_buffhd !=
    +					   NULL) {
    +				status =
    +					curr_handler-&gt;do_command_with_buffhd(common, bh);
    +			}
    +		}
    +
    +		goto end;
    </span> 	}
    <span
    class="add">+
    +	common-&gt;data_size_from_cmnd = 0;
    +	sprintf(unknown, &#34;Unknown %02Xh&#34;, common-&gt;cmnd[0]);
    +	status = check_command(common, common-&gt;cmnd_size, DATA_DIR_UNKNOWN, ~0,
    +			       MEDIUM_OPTIONAL, unknown);
    +	if (status == 0) {
    +		common-&gt;curlun-&gt;sense_data = SS_INVALID_COMMAND;
    +		status = -EINVAL;
    +	}
    +
    +end:
    </span> 	up_read(&#38;common-&gt;filesem);
     
         if (status == -EINTR || signal_pending(current))
    <span
    class="hunk">@@ -2082,7 +2153,6 @@ static int do_scsi_command(struct fsg_common *common)
    </span> 	return 0;
     }
     
    <span
    class="del">-
    </span> /*-------------------------------------------------------------------------*/
     
     static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.h
    id=Z2e.:..:20210626211820.107310-3-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.h>diff</a> --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
    index bdeb1e233fc9..84f5d2ffd7d8 100644
    --- a/drivers/usb/gadget/function/storage_common.h
    +++ b/drivers/usb/gadget/function/storage_common.h
    </span><span
    class="hunk">@@ -172,6 +172,11 @@ enum data_direction {
    </span> 	DATA_DIR_NONE
     };
     
    <span
    class="add">+enum medium_required_values {
    +	MEDIUM_OPTIONAL = 0,
    +	MEDIUM_REQUIRED
    +};
    +
    </span> static inline struct fsg_lun *fsg_lun_from_dev(struct device *dev)
     {
         return container_of(dev, struct fsg_lun, dev);
    -- 
    2.32.0
    
    
    <a
    href=#ma4dcc8b46e33a8365a8dca614cab4b78501d241c
    id=ea4dcc8b46e33a8365a8dca614cab4b78501d241c>^</a> <a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-3-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#ra4dcc8b46e33a8365a8dca614cab4b78501d241c>16+ messages in thread</a></pre><hr><pre><a
    href=#e992ff2558771731a4569b5f8b060a9e264f524d1
    id=m992ff2558771731a4569b5f8b060a9e264f524d1>*</a> <b>[PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</b>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
      2021-06-26 21:18 ` <a
    href="#ma15d1b956bb4d021019ecfe176f738e38de1c946">[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</a> Igor Kononenko
      2021-06-26 21:18 ` <a
    href="#ma4dcc8b46e33a8365a8dca614cab4b78501d241c">[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</a> Igor Kononenko
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      2021-06-27 14:29   ` <a
    href="#m35fd048e76c49d9594d614700b86a72f47f5ee9f">Alan Stern</a>
      2021-06-26 21:18 ` <a
    href="#m01c73ecd2cd3cae217ec69ffe5b54823285cca9e">[PATCH 4/6] fms: Support the DVD/BD images size over 2.1Gb</a> Igor Kononenko
                       ` <a
    href=#r01c73ecd2cd3cae217ec69ffe5b54823285cca9e>(2 subsequent siblings)</a>
      <a
    href=#r992ff2558771731a4569b5f8b060a9e264f524d1>5 siblings, 1 reply; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/raw">raw</a>)
      To: Felipe Balbi, Greg Kroah-Hartman, Jens Axboe
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626211856">linux-usb</a>, <a
    href="../../../lkml/?t=20210626211856">linux-kernel</a>
    
    The DVD-ROM required the SCSI 6.25 READ TOC/PMA/ATIP Command formats:
     * Response Format 0000b: Formatted TOC
     * Response Format 0001b: Multi-session Information
    (MMC-6 Specification).
    
    This patch adds an implementation of that described above formats.
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    href=#Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>drivers/usb/gadget/function/f_mass_storage.c</a> |  99 +++++++++--
     <a
    id=iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c
    href=#Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c>drivers/usb/gadget/function/storage_common.c</a> |  10 +-
     <a
    id=iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    href=#Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>include/uapi/linux/cdrom.h</a>                   | 177 +++++++++++++++++++
     3 files <a href="#e992ff2558771731a4569b5f8b060a9e264f524d1">changed</a>, 261 insertions(+), 25 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    id=Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>diff</a> --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
    index c3fddee21b53..4865937799aa 100644
    --- a/drivers/usb/gadget/function/f_mass_storage.c
    +++ b/drivers/usb/gadget/function/f_mass_storage.c
    </span><span
    class="hunk">@@ -223,6 +223,7 @@
    </span> #include &lt;linux/usb/composite.h&gt;
     
     #include &lt;linux/nospec.h&gt;
    <span
    class="add">+#include &lt;linux/cdrom.h&gt;
    </span> 
     #include &#34;configfs.h&#34;
     
    <span
    class="hunk">@@ -1319,29 +1320,93 @@ static int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)
    </span> 
     static int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)
     {
    <span
    class="del">-	struct fsg_lun	*curlun = common-&gt;curlun;
    -	int		msf = common-&gt;cmnd[1] &#38; 0x02;
    -	int		start_track = common-&gt;cmnd[6];
    -	u8		*buf = (u8 *)bh-&gt;buf;
    </span><span
    class="add">+	struct fsg_lun *curlun = common-&gt;curlun;
    +	struct cdb_read_toc_pma_atip *cdb =
    +		(struct cdb_read_toc_pma_atip *)common-&gt;cmnd;
    +	struct read_tpa_header *header = (struct read_tpa_header *)bh-&gt;buf;
    +	struct read_tpa_toc_formatted *data =
    +		(struct read_tpa_toc_formatted *)((u8 *)bh-&gt;buf +
    +						  sizeof(*header));
    +	size_t data_size = sizeof(*header);
    </span> 
    <span
    class="del">-	if ((common-&gt;cmnd[1] &#38; ~0x02) != 0 ||	/* Mask away MSF */
    -			start_track &gt; 1) {
    </span><span
    class="add">+	if (cdb-&gt;format == 0) {
    +		if (cdb-&gt;control == READ_TPA_CTRL_MAGIC_SESS) {
    +			LDBG(curlun,
    +			    &#34;The MMC-3 specifies format a control byte. Using Multi-Session info\n&#34;);
    +			cdb-&gt;format = CDB_TPA_MULTI_SESS_INFO;
    +		}
    +		if (cdb-&gt;control == READ_TPA_CTRL_MAGIC_RAW) {
    +			LDBG(curlun,
    +			    &#34;The MMC-3 specifies format a control byte. Using RAW TOC\n&#34;);
    +			cdb-&gt;format = CDB_TPA_RAW_TOC;
    +		}
    +	}
    +
    +	/* Currently support response format 0000b: Formatted TOC only */
    +	if (cdb-&gt;format &gt; CDB_TPA_MULTI_SESS_INFO) {
    +		LDBG(curlun, &#34;Unsupported TOC/PMA/ATIP format: %02Xh\n&#34;,
    +		    cdb-&gt;format);
    </span> 		curlun-&gt;sense_data = SS_INVALID_FIELD_IN_CDB;
             return -EINVAL;
         }
     
    <span
    class="del">-	memset(buf, 0, 20);
    -	buf[1] = (20-2);		/* TOC data length */
    -	buf[2] = 1;			/* First track number */
    -	buf[3] = 1;			/* Last track number */
    -	buf[5] = 0x16;			/* Data track, copying allowed */
    -	buf[6] = 0x01;			/* Only track is number 1 */
    -	store_cdrom_address(&#38;buf[8], msf, 0);
    </span><span
    class="add">+	/*
    +	 * We only support one track per disk.
    +	 * We also needs to indicate the number of the last track
    +	 */
    +	if (cdb-&gt;number &gt; 1 &#38;&#38; cdb-&gt;number != READ_TPA_LEADOUT_TRACK) {
    +		curlun-&gt;sense_data = SS_INVALID_FIELD_IN_CDB;
    +		return -EINVAL;
    +	}
    </span> 
    <span
    class="del">-	buf[13] = 0x16;			/* Lead-out track is data */
    -	buf[14] = 0xAA;			/* Lead-out track number */
    -	store_cdrom_address(&#38;buf[16], msf, curlun-&gt;num_sectors);
    -	common-&gt;data_size_to_handle = 20;
    </span><span
    class="add">+	/*
    +	 * MULTI-SESSIOIN information must be reported only for first track.
    +	 */
    +	if (cdb-&gt;format == CDB_TPA_MULTI_SESS_INFO &#38;&#38; cdb-&gt;number &gt; 1) {
    +		curlun-&gt;sense_data = SS_INVALID_FIELD_IN_CDB;
    +		return -EINVAL;
    +	}
    +
    +	memset(header, 0, sizeof(*header));
    +	header-&gt;n_first_stf = 1;
    +	header-&gt;n_last_stf = 1;
    +
    +	memset(data, 0, sizeof(*data));
    +	data-&gt;addr = 1;
    +	data-&gt;control = TPA_SECTOR_MODE2_MIXED;
    +	data-&gt;track_number = cdb-&gt;number;
    +	data_size += sizeof(*data);
    +
    +	/*
    +	 * We have too case:
    +	 *	1)	The request Track Number == 1.
    +	 *		We shall set 2 descriptors: First Track, Lead-Out Track
    +	 *	2)	The requested Track Number == 0xAA
    +	 *		Only Lead-Out descriptor shall be set
    +	 */
    +	if (cdb-&gt;number == 1) {
    +		DBG(common, &#34;Fill first track addr\n&#34;);
    +		store_cdrom_address((u8 *)&#38;data-&gt;start_addr_track, cdb-&gt;msf, 0);
    +
    +		data += 1; /* Add one more descriptor */
    +		data_size += sizeof(*data);
    +		memset(data, 0, sizeof(*data));
    +		/* setting the lead-out track info. First part of data*/
    +		data-&gt;addr = 1;
    +		data-&gt;control = TPA_SECTOR_MODE2_MIXED;
    +		data-&gt;track_number = READ_TPA_LEADOUT_TRACK;
    +	}
    +
    +	/*
    +	 * Lead-out track must be set anyway.
    +	 * If 0xAA Track is requested - the first part of data is already set.
    +	 */
    +	DBG(common, &#34;Fill last track addr\n&#34;);
    +	store_cdrom_address((u8 *)&#38;data-&gt;start_addr_track,
    +				cdb-&gt;msf, curlun-&gt;num_sectors);
    +
    +	header-&gt;length = cpu_to_be16(data_size - sizeof(header-&gt;length));
    +	common-&gt;data_size_to_handle = data_size;
    </span> 	return 0;
     }
     
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c
    id=Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c>diff</a> --git a/drivers/usb/gadget/function/storage_common.c b/drivers/usb/gadget/function/storage_common.c
    index b859a158a414..b883b8b7b05b 100644
    --- a/drivers/usb/gadget/function/storage_common.c
    +++ b/drivers/usb/gadget/function/storage_common.c
    </span><span
    class="hunk">@@ -24,6 +24,7 @@
    </span> #include &lt;linux/file.h&gt;
     #include &lt;linux/fs.h&gt;
     #include &lt;linux/usb/composite.h&gt;
    <span
    class="add">+#include &lt;linux/cdrom.h&gt;
    </span> 
     #include &#34;storage_common.h&#34;
     
    <span
    class="hunk">@@ -295,14 +296,7 @@ void store_cdrom_address(u8 *dest, int msf, u32 addr)
    </span> {
         if (msf) {
             /* Convert to Minutes-Seconds-Frames */
    <span
    class="del">-		addr &gt;&gt;= 2;		/* Convert to 2048-byte frames */
    -		addr += 2*75;		/* Lead-in occupies 2 seconds */
    -		dest[3] = addr % 75;	/* Frames */
    -		addr /= 75;
    -		dest[2] = addr % 60;	/* Seconds */
    -		addr /= 60;
    -		dest[1] = addr;		/* Minutes */
    -		dest[0] = 0;		/* Reserved */
    </span><span
    class="add">+		lba_to_msf(addr, &#38;dest[1], &#38;dest[2], &#38;dest[3]);
    </span> 	} else {
             /* Absolute sector */
             put_unaligned_be32(addr, dest);
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    id=Z2e.:..:20210626211820.107310-4-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>diff</a> --git a/include/uapi/linux/cdrom.h b/include/uapi/linux/cdrom.h
    index 6c34f6e2f1f7..1d7b4333c3aa 100644
    --- a/include/uapi/linux/cdrom.h
    +++ b/include/uapi/linux/cdrom.h
    </span><span
    class="hunk">@@ -947,4 +947,181 @@ struct rm_feature_desc {
    </span> 	__u8 reserved4;
     };
     
    <span
    class="add">+/**
    + * The READ TOC/PMA/ATIP format field values
    + */
    +enum cdb_read_tpa_format {
    +	/**
    +	 * The Track/Session Number field specifies starting track number
    +	 * for which the data is returned. For multi-session discs, TOC
    +	 * data is returned for all sessions. Track number AAh is reported
    +	 * only for the Lead-out area of the last complete session.
    +	 */
    +	CDB_TPA_FORMATTED_TOC,
    +	/**
    +	 * This format returns the first complete session number, last
    +	 * complete session number and last complete session starting address.
    +	 * In this format, the Track/Session Number field is reserved and
    +	 * should be set to 00h.
    +	 * NOTE: This format provides the Host access to the last closed
    +	 * session starting address quickly.
    +	 */
    +	CDB_TPA_MULTI_SESS_INFO,
    +	/**
    +	 * This format returns all Q sub-code data in the Lead-In (TOC) areas
    +	 * starting from a session number as specified in the Number
    +	 * Track/Session Number field.
    +	 * In this mode, the Drive shall support Q Sub-channel POINT field
    +	 * value of A0h, A1h, A2h, Track numbers, B0h, B1h, B2h, B3h, B4h, C0h,
    +	 * and C1h.
    +	 * There is no defined LBA addressing and MSF bit shall be set to one.
    +	 */
    +	CDB_TPA_RAW_TOC,
    +	/**
    +	 * This format returns Q sub-channel data in the PMA area. In this
    +	 * format, the Track/Session Number field is reserved and shall be
    +	 * set to 00h. There is no defined LBA addressing and MSF bit
    +	 * shall be set to one.
    +	 */
    +	CDB_TPA_PMA,
    +	/**
    +	 * This format returns ATIP data. In this format, the Track/Session
    +	 * Number field is reserved and shall be set to 00h. There is no
    +	 * defined LBA addressing and MSF bit shall be set to one.
    +	 */
    +	CDB_TPA_ATIP,
    +	/**
    +	 * This format returns CD-TEXT information that is recorded in the
    +	 * Lead-in area as R-W Sub-channel Data.
    +	 */
    +	CDB_TPA_CD_TEXT,
    +};
    +
    +#define TPA_SECTOR_MODE0		(0x00)
    +#define TPA_SECTOR_AUDIO		(0x01)
    +#define TPA_SECTOR_MODE1		(0x02)
    +#define TPA_SECTOR_MODE2		(0x03)
    +#define TPA_SECTOR_MODE2_FORM1		(0x04)
    +#define TPA_SECTOR_MODE2_FORM2		(0x05)
    +#define TPA_SECTOR_MODE2_MIXED		(TPA_SECTOR_MODE1 | TPA_SECTOR_MODE2_FORM1)
    +#define TPA_SECTOR_RAW				(0x07)
    +#define TPA_SECTOR_RAW_SCRAMBLED	(0x08)
    +
    +/**
    + * @brief The READ TOC/PMA/ATIP CDB (43h)
    + * The READ TOC/PMA/ATIP command requests that the Drive read data from a
    + * Table of Contents, the Program Memory Area (PMA), or the Absolute Time
    + * in Pre-Grove (ATIP) from CD media, format according to CDB parameters
    + * and transfer the result to the Host.
    + */
    +struct cdb_read_toc_pma_atip {
    +	__u8 code;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved1 : 6;
    +	/**
    +	 * When MSF is set to zero, the address fields in some returned data
    +	 * formats shall be in LBA form. When MSF is set to one, the address
    +	 * fields in some returned data formats shall be in MSF form
    +	 */
    +	__u8 msf : 1;
    +	__u8 reserved2 : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 1;
    +	__u8 msf : 1;
    +	__u8 reserved1 : 6;
    +#endif
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved3 : 4;
    +	/**
    +	 * The Format field is used to select specific returned data format
    +	 * according to @enum cdb_read_tpa_format
    +	 */
    +	__u8 format : 4;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 format : 4;
    +	__u8 reserved3 : 4;
    +#endif
    +
    +	__u8 reserved4[3];
    +	/**
    +	 * The Track/Session Number field provides a method to restrict the
    +	 * returned of some data formats to a specific session or a track range
    +	 */
    +	__u8 number;
    +
    +	/**
    +	 * The Allocation Length field specifies the maximum number of bytes that
    +	 * may be returned by the Drive.
    +	 * An Allocation Length field of zero shall not be considered an error
    +	 */
    +	__be16 length;
    +
    +	__u8 control;
    +} __packed;
    +
    +#define READ_TPA_LEADOUT_TRACK	(0xAAU)
    +/*
    + * Control magic byte
    + * Some legacy media recorder implementations set the control byte,
    + * helping determine the relevant TOC/PMA/ATIP formats.
    + * We should support this as well.
    + */
    +#define READ_TPA_CTRL_MAGIC_SESS	(0x40U)
    +#define READ_TPA_CTRL_MAGIC_RAW		(0x80U)
    +
    +/**
    + * @brief READ TOC/PMA/ATIP Data list header
    + * The response data list shows the general description of the response data
    + * to the Read TOC/PMA/ATIP command.
    + */
    +struct read_tpa_header {
    +	__be16 length;
    +	/* First Track/Session/Reserved Field */
    +	__u8 n_first_stf;
    +	/* Last Track/Session/Reserved Field */
    +	__u8 n_last_stf;
    +} __packed;
    +
    +/**
    + * @brief Response Format 0000b: Formatted TOC
    + * The response data consist of four header bytes and zero or more track
    + * descriptors.
    + */
    +struct read_tpa_toc_formatted {
    +	__u8 reserved1;
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	/**
    +	 * The ADR field gives the type of information encoded in the Q Sub-channel
    +	 * of the block where this TOC entry was found.
    +	 */
    +	__u8 addr : 4;
    +	/**
    +	 * The CONTROL Field indicates the attributes of the track.
    +	 */
    +	__u8 control : 4;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 control : 4;
    +	__u8 addr : 4;
    +#endif
    +	/**
    +	 * The Track Start Address contains the address of the first block with user
    +	 * information for that track number as read from the Table of Contents.
    +	 * A MSF bit of zero indicates that the Track Start Address field shall contain
    +	 * a logical block address.
    +	 * A MSF bit of one indicates the Logical Block Address field shall contain a
    +	 * MSF address
    +	 */
    +	__u8 track_number;
    +	__u8 reserved2;
    +	/**
    +	 * The Track Number field indicates the track number for that the data in the
    +	 * TOC track descriptor is valid. A track number of READ_TPA_LEADOUT_TRACK
    +	 * indicates that the track descriptor is for the start of the Lead-out area.
    +	 */
    +	__be32 start_addr_track;
    +} __packed;
    +
    +
    </span> #endif /* _UAPI_LINUX_CDROM_H */
    -- 
    2.32.0
    
    
    <a
    href=#m992ff2558771731a4569b5f8b060a9e264f524d1
    id=e992ff2558771731a4569b5f8b060a9e264f524d1>^</a> <a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-4-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#r992ff2558771731a4569b5f8b060a9e264f524d1>16+ messages in thread</a></pre><hr><pre><a
    href=#e01c73ecd2cd3cae217ec69ffe5b54823285cca9e
    id=m01c73ecd2cd3cae217ec69ffe5b54823285cca9e>*</a> <u
    id=u><b>[PATCH 4/6] fms: Support the DVD/BD images size over 2.1Gb</b></u>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
                       ` <a
    href=#r992ff2558771731a4569b5f8b060a9e264f524d1>(2 preceding siblings ...)</a>
      2021-06-26 21:18 ` <a
    href="#m992ff2558771731a4569b5f8b060a9e264f524d1">[PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</a> Igor Kononenko
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d">[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
      2021-06-26 21:18 ` <a
    href="#mf9201ae82cadb63aa148811fdeae78d3d4c1fa16">[PATCH 6/6] FMS: Add SCSI Read Disc Information command</a> Igor Kononenko
      <a
    href=#r01c73ecd2cd3cae217ec69ffe5b54823285cca9e>5 siblings, 0 replies; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/raw">raw</a>)
      To: Felipe Balbi, Greg Kroah-Hartman
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626211855">linux-usb</a>, <a
    href="../../../lkml/?t=20210626211855">linux-kernel</a>
    
    Adds the ability to use the FMS image size greater than 2.1Gb.  This
    limitation is due to the maximum number of available frames on the
    CD-ROM media.
    
    An incoming implementation of additional media formats (DVD-ROM, BD-ROM)
    should support both formats&#39; possible capacity.
    
    End-user-impact: Now, the FMS able to use a medium-image backend  file,
                     which size is more significant than 2.1Gb
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-5-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c
    href=#Z2e.:..:20210626211820.107310-5-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c>drivers/usb/gadget/function/storage_common.c</a> | 9 +--------
     1 file <a href="#e01c73ecd2cd3cae217ec69ffe5b54823285cca9e">changed</a>, 1 insertion(+), 8 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-5-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c
    id=Z2e.:..:20210626211820.107310-5-i.kononenko::40yadro.com:1drivers:usb:gadget:function:storage_common.c>diff</a> --git a/drivers/usb/gadget/function/storage_common.c b/drivers/usb/gadget/function/storage_common.c
    index b883b8b7b05b..468f7622b11d 100644
    --- a/drivers/usb/gadget/function/storage_common.c
    +++ b/drivers/usb/gadget/function/storage_common.c
    </span><span
    class="hunk">@@ -242,15 +242,8 @@ int fsg_lun_open(struct fsg_lun *curlun, const char *filename)
    </span> 
         num_sectors = size &gt;&gt; blkbits; /* File size in logic-block-size blocks */
         min_sectors = 1;
    <span
    class="del">-	if (curlun-&gt;cdrom) {
    </span><span
    class="add">+	if (curlun-&gt;cdrom)
    </span> 		min_sectors = 300;	/* Smallest track is 300 frames */
    <span
    class="del">-		if (num_sectors &gt;= 256*60*75) {
    -			num_sectors = 256*60*75 - 1;
    -			LINFO(curlun, &#34;file too big: %s\n&#34;, filename);
    -			LINFO(curlun, &#34;using only first %d blocks\n&#34;,
    -					(int) num_sectors);
    -		}
    -	}
    </span> 	if (num_sectors &lt; min_sectors) {
             LINFO(curlun, &#34;file too small: %s\n&#34;, filename);
             rc = -ETOOSMALL;
    -- 
    2.32.0
    
    
    <a
    href=#m01c73ecd2cd3cae217ec69ffe5b54823285cca9e
    id=e01c73ecd2cd3cae217ec69ffe5b54823285cca9e>^</a> <a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-5-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#r01c73ecd2cd3cae217ec69ffe5b54823285cca9e>16+ messages in thread</a></pre><hr><pre><a
    href=#ed657bf4dd0d02f809976e2561e2c45855edcc57d
    id=md657bf4dd0d02f809976e2561e2c45855edcc57d>*</a> <b>[PATCH 5/6] FMS: Add the SCSI Get Configuration command.</b>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
                       ` <a
    href=#r01c73ecd2cd3cae217ec69ffe5b54823285cca9e>(3 preceding siblings ...)</a>
      2021-06-26 21:18 ` <a
    href="#m01c73ecd2cd3cae217ec69ffe5b54823285cca9e">[PATCH 4/6] fms: Support the DVD/BD images size over 2.1Gb</a> Igor Kononenko
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      2021-06-27  0:44   ` <a
    href="#m31ec12223279c2669d001a846804b3ce28dda048">kernel test robot</a>
                         ` <a
    href=#r31ec12223279c2669d001a846804b3ce28dda048>(2 more replies)</a>
      2021-06-26 21:18 ` <a
    href="#mf9201ae82cadb63aa148811fdeae78d3d4c1fa16">[PATCH 6/6] FMS: Add SCSI Read Disc Information command</a> Igor Kononenko
      <a
    href=#rd657bf4dd0d02f809976e2561e2c45855edcc57d>5 siblings, 3 replies; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/raw">raw</a>)
      To: Jens Axboe, Felipe Balbi, Greg Kroah-Hartman,
        James E.J. Bottomley, Martin K. Petersen
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-ide/?t=20210626211906">linux-ide</a>, <a
    href="../../../lkml/?t=20210626211906">linux-kernel</a>, <a
    href="../../../linux-usb/?t=20210626211906">linux-usb</a>,
        <a
    href="../../../linux-scsi/?t=20210626211906">linux-scsi</a>
    
    The SCSI Get Configuration command is required to obtain information
    about a CD/DVD/BL device (MMC-6, 6.5 GET CONFIGURATION Command).
    
    The aforementioned ability will be expected by several multimedia
    consumers, such as OS MS Windows, OS ESXi, etc., for selecting the
    appropriate FS driver.
    
    End-user-impact: The FMS devices consumers can now retrieve their
                     capabilities.
                     FMS supports the ISO-13346(UDF) multimedia file systems
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:ata:libata-zpodd.c
    href=#Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:ata:libata-zpodd.c>drivers/ata/libata-zpodd.c</a>                   |   8 +-
     <a
    id=iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    href=#Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>drivers/usb/gadget/function/f_mass_storage.c</a> | 222 +++++
     <a
    id=iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h
    href=#Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h>include/scsi/scsi_proto.h</a>                    |   1 +
     <a
    id=iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    href=#Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>include/uapi/linux/cdrom.h</a>                   | 844 ++++++++++++++++++-
     4 files <a href="#ed657bf4dd0d02f809976e2561e2c45855edcc57d">changed</a>, 1041 insertions(+), 34 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:ata:libata-zpodd.c
    id=Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:ata:libata-zpodd.c>diff</a> --git a/drivers/ata/libata-zpodd.c b/drivers/ata/libata-zpodd.c
    index eefda51f97d3..e49ff795a506 100644
    --- a/drivers/ata/libata-zpodd.c
    +++ b/drivers/ata/libata-zpodd.c
    </span><span
    class="hunk">@@ -54,7 +54,7 @@ static enum odd_mech_type zpodd_get_mech_type(struct ata_device *dev)
    </span> {
         char *buf;
         unsigned int ret;
    <span
    class="del">-	struct rm_feature_desc *desc;
    </span><span
    class="add">+	struct cdf_removable_medium *desc;
    </span> 	struct ata_taskfile tf;
         static const char cdb[ATAPI_CDB_LEN] = {  GPCMD_GET_CONFIGURATION,
                 2,      /* only 1 feature descriptor requested */
    <span
    class="hunk">@@ -82,15 +82,15 @@ static enum odd_mech_type zpodd_get_mech_type(struct ata_device *dev)
    </span> 		return ODD_MECH_TYPE_UNSUPPORTED;
         }
     
    <span
    class="del">-	if (be16_to_cpu(desc-&gt;feature_code) != 3) {
    </span><span
    class="add">+	if (be16_to_cpu(desc-&gt;code) != 3) {
    </span> 		kfree(buf);
             return ODD_MECH_TYPE_UNSUPPORTED;
         }
     
    <span
    class="del">-	if (desc-&gt;mech_type == 0 &#38;&#38; desc-&gt;load == 0 &#38;&#38; desc-&gt;eject == 1) {
    </span><span
    class="add">+	if (desc-&gt;mechanism == 0 &#38;&#38; desc-&gt;load == 0 &#38;&#38; desc-&gt;eject == 1) {
    </span> 		kfree(buf);
             return ODD_MECH_TYPE_SLOT;
    <span
    class="del">-	} else if (desc-&gt;mech_type == 1 &#38;&#38; desc-&gt;load == 0 &#38;&#38;
    </span><span
    class="add">+	} else if (desc-&gt;mechanism == 1 &#38;&#38; desc-&gt;load == 0 &#38;&#38;
    </span> 		   desc-&gt;eject == 1) {
             kfree(buf);
             return ODD_MECH_TYPE_DRAWER;
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    id=Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>diff</a> --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
    index 4865937799aa..7e736e5594f9 100644
    --- a/drivers/usb/gadget/function/f_mass_storage.c
    +++ b/drivers/usb/gadget/function/f_mass_storage.c
    </span><span
    class="hunk">@@ -366,6 +366,87 @@ struct cdb_handler {
    </span> 	/* SCSI command ASCII name */
         char *name;
     };
    <span
    class="add">+/*-------------------------------------------------------------------------*/
    +
    +#define CDF_PROFILES_COUNT (ARRAY_SIZE(cdf_supported_profiles))
    +
    +/* List of supported profiles */
    +static struct mmc_profile cdf_supported_profiles[] = {
    +	{ .profile = cpu_to_be16(MMC_PROFILE_BD_ROM) },
    +	{ .profile = cpu_to_be16(MMC_PROFILE_DVD_ROM) },
    +	{ .profile = cpu_to_be16(MMC_PROFILE_CD_ROM) },
    +};
    +
    +struct cdf_profile_list_custom {
    +	struct cdf_profile_list header;
    +	/* We support several profiles, whose indices are declared in the
    +	 * enum above
    +	 */
    +	struct mmc_profile profiles[CDF_PROFILES_COUNT];
    +} __packed;
    +
    +/**
    + * Type to allocate of all supported features
    + * @param populate - callback to fill the specified feature data which
    + * is depended by medium
    + */
    +struct cdr_features;
    +struct cdr_features {
    +	union {
    +		struct cdf_profile_list_custom profile_list;
    +		struct cdf_core core;
    +		struct cdf_morphing morphing;
    +		struct cdf_removable_medium removable;
    +		struct cdf_random_readable random_readable;
    +		struct cdf_multi_read multi_read;
    +		struct cdf_cd_read cd_read;
    +		struct cdf_dvd_read dvd_read;
    +		struct cdf_rt_streaming rt_streaming;
    +	} __packed feature;
    +	void (*populate)(struct fsg_common *common,
    +			 struct cdr_features **features);
    +};
    +
    +/**
    + * @brief Adjust the Profile List members of actual data which is depended
    + * on the inserted medium image
    + *
    + * @param common - the FSG instance
    + * @param feature - a list of profile descriptors which to be configured
    + */
    +static void cdf_populate_profile_list(struct fsg_common *common,
    +				      struct cdr_features **feature);
    +
    +#define CDF_SET_VPC(v, p, c) .vpc = { .ver = (v), .per = (p), .cur = (c) }
    +
    +#define CDF_FT_SIZE(member)                                                    \
    +	((sizeof(((struct cdr_features *)0)-&gt;feature.member)) -                \
    +	 sizeof(struct cdb_ft_generic))
    +
    +#define CDR_FT_ITEM(item, c, ...)                                              \
    +	CDR_FT_ITEM_S(item, c, CDF_FT_SIZE(item), __VA_ARGS__)
    +
    +#define CDR_FT_ITEM_S(item, c, s, ...)                                         \
    +	.feature.item = { .code = cpu_to_be16(c), .length = (s), __VA_ARGS__ }
    +
    +static struct cdr_features features_table[] = {
    +	{ CDR_FT_ITEM_S(profile_list.header, CDF_PROFILE_LIST_CODE,
    +			CDF_FT_SIZE(profile_list), CDF_SET_VPC(0, 1, 1)),
    +	  .populate = &#38;cdf_populate_profile_list },
    +	{ CDR_FT_ITEM(core, CDF_CORE, CDF_SET_VPC(2, 1, 1), .dbevent = 1,
    +		      .interface = cpu_to_be32(CF_PIS_USB)) },
    +	{ CDR_FT_ITEM(morphing, CDF_MORPHING_CODE, CDF_SET_VPC(1, 1, 1),
    +		      .ocevent = 1) },
    +	{ CDR_FT_ITEM(removable, CDF_REMOVEBLE_MEDIA, CDF_SET_VPC(2, 1, 1),
    +		      .mechanism = CDF_LMT__TRAY_TYPE, .eject = 1, .lock = 1) },
    +	{ CDR_FT_ITEM(random_readable, CDF_RANDOM_READ, CDF_SET_VPC(0, 0, 1),
    +		      .block_size = cpu_to_be32(CD_FRAMESIZE),
    +		      .blocking = cpu_to_be16(0x10), .pp = 1) },
    +	{ CDR_FT_ITEM(dvd_read, CDF_DVD_READ, CDF_SET_VPC(2, 1, 1),
    +		      .multi110 = 1, .dualr = 1) },
    +	{ CDR_FT_ITEM(rt_streaming, CDF_REAL_TIME_STREAM, CDF_SET_VPC(5, 0, 1),
    +		      .rbcb = 1, .scs = 1, .mp2a = 1, .wspd = 1, .sw = 1) },
    +};
    </span> 
     /*------------------------------------------------------------------------*/
     
    <span
    class="hunk">@@ -1851,6 +1932,143 @@ static void send_status(struct fsg_common *common)
    </span> 	return;
     }
     
    <span
    class="add">+/**
    + * Attempts to guess medium type by looking at the length of the disc layout.
    + */
    +static inline __be16 cdr_guess_medium_type(struct fsg_common *common)
    +{
    +	struct fsg_lun *curlun = common-&gt;curlun;
    +	size_t length = curlun-&gt;num_sectors;
    +
    +	if (length &lt;= CD_MAX_FRAMES) {
    +		LDBG(curlun, &#34;Disc layout size implies CD-ROM image\n&#34;);
    +		return MMC_PROFILE_CD_ROM;
    +	} else if (length &lt;= CD_DVD_MAX_FRAMES) {
    +		LDBG(curlun,
    +		     &#34;Disc layout size implies single-layer DVD-ROM image\n&#34;);
    +		return MMC_PROFILE_DVD_ROM;
    +	} else if (length &lt;= CD_DVDDL_MAX_FRAMES) {
    +		LDBG(curlun,
    +		     &#34;Disc layout size implies dual-layer DVD-ROM image\n&#34;);
    +		return MMC_PROFILE_DVD_ROM;
    +	} else if (length &lt;= CD_BD_MAX_FRAMES) {
    +		LDBG(curlun,
    +		     &#34;Disc layout size implies single-layer BD-ROM image\n&#34;);
    +		return MMC_PROFILE_BD_ROM;
    +	} else if (length &lt;= CD_BDDL_MAX_FRAMES) {
    +		LDBG(curlun,
    +		     &#34;Disc layout size implies dual-layer BD-ROM image\n&#34;);
    +		return MMC_PROFILE_BD_ROM;
    +	}
    +
    +	LDBG(curlun,
    +	     &#34;Disc layout size (%u) exceeds all known media types, assuming BD - ROM !\n&#34;,
    +	     length);
    +	return MMC_PROFILE_BD_ROM;
    +}
    +
    +/* Adjust current profile which depended on an inserted medium */
    +static inline void cdf_populate_profile_list(struct fsg_common *common,
    +					     struct cdr_features **feature)
    +{
    +	__be16 current_media_type = cdr_guess_medium_type(common);
    +	struct mmc_profile *profiles =
    +		(*feature)-&gt;feature.profile_list.profiles;
    +	int i;
    +
    +	/* copy profile list to the response buffer */
    +	memcpy(profiles, cdf_supported_profiles,
    +	       sizeof(cdf_supported_profiles));
    +	for (i = 0; i &lt; CDF_PROFILES_COUNT; ++i) {
    +		/*
    +		 * Reset the current profile bit,
    +		 * because it might be set from the previous one
    +		 */
    +		profiles[i].current_p = 0;
    +		if (be16_to_cpu(profiles[i].profile) == current_media_type) {
    +			DBG(common, &#34;Fill current profile: curr=(%04Xh)\n&#34;,
    +			    be16_to_cpu(profiles[i].profile));
    +			profiles[i].current_p = 1;
    +		}
    +	}
    +}
    +
    +static int do_get_configuration(struct fsg_common *common,
    +				struct fsg_buffhd *bh)
    +{
    +	struct fsg_lun *curlun = common-&gt;curlun;
    +	int i;
    +	struct cdb_get_configuration *cdb =
    +		(struct cdb_get_configuration *)common-&gt;cmnd;
    +	size_t buffer_size = sizeof(struct feature_header);
    +	size_t generic_desc_size = sizeof(struct cdb_ft_generic);
    +	struct feature_header *ret_header = (struct feature_header *)bh-&gt;buf;
    +	u8 *ret_data = ((u8 *)ret_header) + buffer_size;
    +
    +	LDBG(curlun, &#34;Requesting features from 0x%04X, with RT flag 0x%02X\n&#34;,
    +	     be16_to_cpu(cdb-&gt;sfn), cdb-&gt;rt);
    +
    +	if (!common-&gt;curlun || !common-&gt;curlun-&gt;cdrom)
    +		return -EINVAL;
    +
    +	/* Go over *all* features, and copy them according to RT value */
    +	for (i = 0; i &lt; ARRAY_SIZE(features_table); ++i) {
    +		struct cdb_ft_generic *generic =
    +			(struct cdb_ft_generic *)&#38;features_table[i];
    +		struct cdr_features *feature = &#38;features_table[i];
    +
    +		if (feature-&gt;populate != NULL)
    +			feature-&gt;populate(common, &#38;feature);
    +
    +		// a) RT is 0x00 and feature&#39;s code &gt;= SFN
    +		// b) RT is 0x01, feature&#39;s code &gt;= SFN and feature has &#39;current&#39; bit set
    +		// c) RT is 0x02 and feature&#39;s code == SFN
    +
    +		if (be16_to_cpu(generic-&gt;code) &gt;= be16_to_cpu(cdb-&gt;sfn)) {
    +			if ((cdb-&gt;rt == CDR_CFG_RT_FULL) ||
    +			    (cdb-&gt;rt == CDR_CFG_RT_CURRENT &#38;&#38;
    +			     generic-&gt;vpc.cur) ||
    +			    (cdb-&gt;rt == CDR_CFG_RT_SPECIFIED_SFN &#38;&#38;
    +			     be16_to_cpu(generic-&gt;code) ==
    +				     be16_to_cpu(cdb-&gt;sfn))) {
    +				LDBG(curlun, &#34;Copying feature 0x%04X\n&#34;,
    +				     be16_to_cpu(generic-&gt;code));
    +
    +				memset(ret_data, 0,
    +				       (generic-&gt;length + generic_desc_size));
    +				/* Copy feature */
    +				memcpy(ret_data, feature,
    +				       (generic-&gt;length + generic_desc_size));
    +				buffer_size +=
    +					(generic-&gt;length + generic_desc_size);
    +				ret_data +=
    +					(generic-&gt;length + generic_desc_size);
    +
    +				/* Break the loop if RT is CDR_CFG_RT_SPECIFIED_SFN */
    +				if (cdb-&gt;rt == CDR_CFG_RT_SPECIFIED_SFN) {
    +					LDBG(curlun,
    +					     &#34;Got the feature we wanted (0x%04X), breaking the loop\n&#34;,
    +					     be16_to_cpu(cdb-&gt;sfn));
    +					break;
    +				}
    +			}
    +		}
    +	}
    +
    +	memset(ret_header, 0, sizeof(struct feature_header));
    +	/* Header */
    +	ret_header-&gt;data_len = cpu_to_be32(buffer_size - generic_desc_size);
    +	ret_header-&gt;curr_profile =
    +		cpu_to_be16(cdr_guess_medium_type(common));
    +
    +	dump_msg(common, &#34;feature header&#34;, (u8 *)ret_header,
    +		 sizeof(struct feature_header));
    +
    +	dump_msg(common, &#34;features table&#34;, (u8 *)bh-&gt;buf, buffer_size);
    +
    +	common-&gt;data_size_to_handle = buffer_size;
    +	return 0;
    +}
    </span> 
     /*-------------------------------------------------------------------------*/
     
    <span
    class="hunk">@@ -2035,6 +2253,9 @@ static struct cdb_command_check cdb_checker_table[] = {
    </span> 	{ CDB_REG_CHECKER(TEST_UNIT_READY, 6, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
                   0x0000, MEDIUM_REQUIRED) },
     
    <span
    class="add">+	{ CDB_REG_NO_CHECKER(GET_CONFIGURATION, CDB_SIZE_FIELD_7,
    +			     DATA_DIR_TO_HOST, MEDIUM_REQUIRED) },
    +
    </span> 	{ CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
                       0x0000, MEDIUM_REQUIRED) },
         { CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
    <span
    class="hunk">@@ -2065,6 +2286,7 @@ static struct cdb_handler cdb_handlers_table[] = {
    </span> 	{ CDB_REG_HANDLER(SYNCHRONIZE_CACHE, &#38;do_synchronize_cache) },
         { CDB_REG_HANDLER(TEST_UNIT_READY, NULL) },
     
    <span
    class="add">+	{ CDB_REG_HANDLER_BUFFHD(GET_CONFIGURATION, &#38;do_get_configuration) },
    </span> 	/*
          * Although optional, this command is used by MS-Windows.  We
          * support a minimal version: BytChk must be 0.
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h
    id=Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h>diff</a> --git a/include/scsi/scsi_proto.h b/include/scsi/scsi_proto.h
    index c36860111932..6b2a8ee1f0a3 100644
    --- a/include/scsi/scsi_proto.h
    +++ b/include/scsi/scsi_proto.h
    </span><span
    class="hunk">@@ -73,6 +73,7 @@
    </span> #define UNMAP		      0x42
     #define READ_TOC              0x43
     #define READ_HEADER           0x44
    <span
    class="add">+#define GET_CONFIGURATION     0x46
    </span> #define GET_EVENT_STATUS_NOTIFICATION 0x4a
     #define LOG_SELECT            0x4c
     #define LOG_SENSE             0x4d
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    id=Z2e.:..:20210626211820.107310-6-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>diff</a> --git a/include/uapi/linux/cdrom.h b/include/uapi/linux/cdrom.h
    index 1d7b4333c3aa..442693fdc059 100644
    --- a/include/uapi/linux/cdrom.h
    +++ b/include/uapi/linux/cdrom.h
    </span><span
    class="hunk">@@ -349,6 +349,12 @@ struct cdrom_generic_command
    </span> /* most drives don&#39;t deliver everything: */
     #define CD_FRAMESIZE_RAW1 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE) /*2340*/
     #define CD_FRAMESIZE_RAW0 (CD_FRAMESIZE_RAW-CD_SYNC_SIZE-CD_HEAD_SIZE) /*2336*/
    <span
    class="add">+/* total frames on the specific medium-disk format */
    +#define CD_MAX_FRAMES			(CD_MINS * CD_SECS * CD_FRAMES)
    +#define CD_DVD_MAX_FRAMES		(2295104)
    +#define CD_DVDDL_MAX_FRAMES	(4173824)
    +#define CD_BD_MAX_FRAMES		(12219392)
    +#define CD_BDDL_MAX_FRAMES		(24438784)
    </span> 
     #define CD_XA_HEAD        (CD_HEAD_SIZE+CD_SUBHEAD_SIZE) /* &#34;before data&#34; part of raw XA frame */
     #define CD_XA_TAIL        (CD_EDC_SIZE+CD_ECC_SIZE) /* &#34;after data&#34; part of raw XA frame */
    <span
    class="hunk">@@ -896,12 +902,173 @@ typedef struct {
    </span> 	__be32 last_rec_address;
     } track_information;
     
    <span
    class="add">+/* CDB Get Configuration command */
    +
    +/**
    + * The Drive shall return the Feature Header and all Feature Descriptors supported by the
    + * Drive without regard to currency
    + */
    +#define CDR_CFG_RT_FULL 0x00
    +/**
    + * The Drive shall return the Feature Header and only those Feature Descriptors in which
    + * the Current bit is set to one.
    + */
    +#define CDR_CFG_RT_CURRENT 0x01
    +/**
    + * The Feature Header and the Feature Descriptor identified by Starting Feature Number
    + * shall be returned. If the Drive does not support the specified feature, only the Feature
    + * Header shall be returned.
    + */
    +#define CDR_CFG_RT_SPECIFIED_SFN 0x02
    +#define CDR_CFG_RT_RESERVED 0x03
    +
    +/**
    + * @brief GET CONFIGURATION Command
    + * The GET CONFIGURATION command provides a Host with information about Drive capabilities;
    + * both current and potential.
    + *
    + * @note The command shall not return a CHECK CONDITION Status due to a pending
    + * UNIT ATTENTION Condition.
    + */
    +struct cdb_get_configuration {
    +	__u8 code;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved1 : 6;
    +	/* The RT field identifies the type of data to be returned by the Drive */
    +	__u8 rt : 2;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 rt : 2;
    +	__u8 reserved1 : 6;
    +#endif
    +	/**
    +	 * The Starting Feature Number field indicates the first Feature number to be returned.
    +	 * All supported Feature numbers higher than the Starting Feature Number shall be
    +	 * returned.
    +	 */
    +	__be16 sfn;
    +	__u8 reserved2[3];
    +	/**
    +	 * The Allocation Length field specifies the maximum length in bytes of the
    +	 * Get Configuration response data. An Allocation Length field of zero indicates that no
    +	 * data shall be transferred
    +	 */
    +	__be16 length;
    +	__u8 control;
    +
    +} __packed;
    +
    +/* Features */
    +
    +/* Feature and Profile Descriptors*/
    +
    +/**
    + * @brief The Version, Persisten and Current byte.
    + * This structure is required for many CDB features.
    + */
    +struct cdb_ft_vpc_byte {
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved1 : 2;
    +	/**
    +	 * The Version field is reserved and shall be set to zero unless otherwise specified
    +	 * within the Feature Description
    +	 */
    +	__u8 ver : 4;
    +	/**
    +	 * The Persistent bit, when set to zero, shall indicate that this Feature may change
    +	 * its current status.
    +	 * When set to one, shall indicate that this Feature is always active.
    +	 * The Drive shall not set this bit to one if the Current bit is, or may become, zero.
    +	 */
    +	__u8 per : 1;
    +	/**
    +	 * The Current bit, when set to zero, indicates that this Feature is not currently
    +	 * active and that the Feature Dependent Data may not be valid.
    +	 * When set to one, this Feature is currently active and the Feature Dependent Data is
    +	 * valid.
    +	 */
    +	__u8 cur : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 cur : 1;
    +	__u8 per : 1;
    +	__u8 ver : 4;
    +	__u8 reserved1 : 2;
    +#endif
    +} __packed;
    +
    +/**
    + * @brief Feature Descriptor generic
    + * A Feature Descriptor shall describe each Feature supported by a Drive. All
    + * Feature descriptors shall be a multiple of four bytes
    + */
    +struct cdb_ft_generic {
    +	/**
    +	 * The Feature Code field shall identify a Feature supported by the Drive
    +	 */
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	/**
    +	 * The Additional Length field indicates the number of Feature specific
    +	 * bytes that follow this header. This field shall be an integral multiple
    +	 * of 4
    +	 */
    +	__u8 length;
    +} __packed;
    +
    +/* Profile list */
    +#define MMC_PROFILE_NONE 0x0000
    +#define MMC_PROFILE_CD_ROM 0x0008
    +#define MMC_PROFILE_CD_R 0x0009
    +#define MMC_PROFILE_CD_RW 0x000A
    +#define MMC_PROFILE_DVD_ROM 0x0010
    +#define MMC_PROFILE_DVD_R_SR 0x0011
    +#define MMC_PROFILE_DVD_RAM 0x0012
    +#define MMC_PROFILE_DVD_RW_RO 0x0013
    +#define MMC_PROFILE_DVD_RW_SR 0x0014
    +#define MMC_PROFILE_DVD_R_DL_SR 0x0015
    +#define MMC_PROFILE_DVD_R_DL_JR 0x0016
    +#define MMC_PROFILE_DVD_RW_DL 0x0017
    +#define MMC_PROFILE_DVD_DDR 0x0018
    +#define MMC_PROFILE_DVD_PLUS_RW 0x001A
    +#define MMC_PROFILE_DVD_PLUS_R 0x001B
    +#define MMC_PROFILE_DVD_PLUS_RW_DL 0x002A
    +#define MMC_PROFILE_DVD_PLUS_R_DL 0x002B
    +#define MMC_PROFILE_BD_ROM 0x0040
    +#define MMC_PROFILE_BD_R_SRM 0x0041
    +#define MMC_PROFILE_BD_R_RRM 0x0042
    +#define MMC_PROFILE_BD_RE 0x0043
    +#define MMC_PROFILE_HDDVD_ROM 0x0050
    +#define MMC_PROFILE_HDDVD_R 0x0051
    +#define MMC_PROFILE_HDDVD_RAM 0x0052
    +#define MMC_PROFILE_HDDVD_RW 0x0053
    +#define MMC_PROFILE_HDDVD_R_DL 0x0058
    +#define MMC_PROFILE_HDDVD_RW_DL 0x005A
    +#define MMC_PROFILE_INVALID 0xFFFF
    +
    +/**
    + * @brief The CDB Feature Header
    + * Response data consists of a header field and zero or more variable length
    + * Feature descriptors
    + */
    </span> struct feature_header {
    <span
    class="add">+	/**
    +	 * The Data Length field indicates the amount of data available given a
    +	 * sufficient allocation length following this field.
    +	 * This length shall not be truncated due to an insufficient Allocation
    +	 * Length
    +	 */
    </span> 	__u32 data_len;
         __u8 reserved1;
         __u8 reserved2;
    <span
    class="add">+	/**
    +	 * The Current Profile field shall identify one of the profiles from the
    +	 * Profile List Feature. If there are no Profiles currently active, this
    +	 * field shall contain zero.
    +	 */
    </span> 	__u16 curr_profile;
    <span
    class="del">-};
    </span><span
    class="add">+} __packed;
    </span> 
     struct mode_page_header {
         __be16 mode_data_length;
    <span
    class="hunk">@@ -912,41 +1079,658 @@ struct mode_page_header {
    </span> 	__be16 desc_length;
     };
     
    <span
    class="del">-/* removable medium feature descriptor */
    -struct rm_feature_desc {
    -	__be16 feature_code;
    </span><span
    class="add">+/**
    + * @brief Profile descriptors are returned in the order of preferred
    + * operation &#8211; most desirable to least desirable. e.g., a DVD-ROM
    + * that is also able to read a CD-ROM should list the DVD-ROM
    + * Profile first and the CD-ROM Profile second.
    + */
    +struct mmc_profile {
    +	/* The Profile Number identifies a Profile */
    +	__be16 profile;
    +
    </span> #if defined(__BIG_ENDIAN_BITFIELD)
    <span
    class="del">-	__u8 reserved1:2;
    -	__u8 feature_version:4;
    -	__u8 persistent:1;
    -	__u8 curr:1;
    </span><span
    class="add">+	__u8 reserved1 : 7;
    +	/**
    +	 * The current_p bit, when set to one, shall indicate that this
    +	 * Profile is currently active.
    +	 */
    +	__u8 current_p : 1;
    </span> #elif defined(__LITTLE_ENDIAN_BITFIELD)
    <span
    class="del">-	__u8 curr:1;
    -	__u8 persistent:1;
    -	__u8 feature_version:4;
    -	__u8 reserved1:2;
    -#endif
    -	__u8 add_len;
    -#if defined(__BIG_ENDIAN_BITFIELD)
    -	__u8 mech_type:3;
    -	__u8 load:1;
    -	__u8 eject:1;
    -	__u8 pvnt_jmpr:1;
    -	__u8 dbml:1;
    -	__u8 lock:1;
    -#elif defined(__LITTLE_ENDIAN_BITFIELD)
    -	__u8 lock:1;
    -	__u8 dbml:1;
    -	__u8 pvnt_jmpr:1;
    -	__u8 eject:1;
    -	__u8 load:1;
    -	__u8 mech_type:3;
    </span><span
    class="add">+	__u8 current_p : 1;
    +	__u8 reserved1 : 7;
    </span> #endif
    <span
    class="add">+
    </span> 	__u8 reserved2;
    <span
    class="del">-	__u8 reserved3;
    -	__u8 reserved4;
    </span><span
    class="add">+} __packed;
    +
    +/**
    + * @brief Profile List Feature (0000h)
    + *
    + * This Feature identifies Profiles supported by the Drive.
    + * Profiles are defined as collections of Features and provide a method
    + * to quickly determine the Drive&#8217;s type.
    + */
    +struct cdf_profile_list {
    +	/* The Feature Code */
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +	/**
    +	 * The Additional Length field shall be set
    +	 * to ((number of Profile Descriptors) * 4).
    +	 */
    +	__u8 length;
    +} __packed;
    +
    +/**
    + * @brief The core feature: phisycal interface standards
    + */
    +enum cdf_cf_pis {
    +	CF_PIS_UNSPECIFIED = 0x00000000U,
    +	CF_PIS_SCSI_FAMILY,
    +	CF_PIS_ATAPI,
    +	CF_PIS_IEEE_1394_1995,
    +	CF_PIS_IEEE_1394A,
    +	CF_PIS_FIBRE_CHANNEL,
    +	CF_PIS_IEEE_1394_B,
    +	CF_PIS_USB,
    +	CF_PIS_RESERVED,
    +	CF_PIS_DEF_INCITS = 0x00010000U,
    +	CF_PIS_DEF_SFF = 0x00020000U,
    +	CF_PIS_DEF_IEEE = 0x00030000U,
    +	CF_PIS_DEF_RESERVED = 0x00040000U
    </span> };
     
    <span
    class="add">+/**
    + * @brief Core Feature (0001h)
    + * This Feature identifies a Drive that supports functionality common
    + * to all devices.
    + */
    +struct cdf_core {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	/* The Additional Length field shall be set to 8. */
    +	__u8 length;
    +	/**
    +	 * The Physical Interface Standard field shall be set to a value
    +	 * selected from @enum cdf_cf_pis
    +	 * It is possible that more than one physical interface exists
    +	 * between the Host and Drive, e.g., an IEEE1394 Host connecting
    +	 * to an ATAPI bridge to an ATAPI Drive. The Drive may not be aware
    +	 * of interfaces beyond the ATAPI.
    +	 */
    +	__be32 interface;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 6;
    +	/**
    +	 * The INQ2 bit permits the Drive to indicate support for certain
    +	 * features of the INQUIRY command. If INQ2 is set to one, the
    +	 * Drive shall support validation of EVPD, Page Code, and the
    +	 * 16-bit Allocation Length fields
    +	 */
    +	__u8 inq2 : 1;
    +	/**
    +	 * DBE (Device Busy Event) shall be set to one.
    +	 */
    +	__u8 dbevent : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 dbevent : 1;
    +	__u8 inq2 : 1;
    +	__u8 reserved2 : 6;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/**
    + * @brief Morphing Feature (0002h)
    + * This Feature identifies the ability of the Drive to notify
    + * A Host about operational changes and accept Host requests to
    + * prevent operational changes.
    + */
    +struct cdf_morphing {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 6;
    +	__u8 ocevent : 1;
    +	__u8 async : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 async : 1;
    +	__u8 ocevent : 1;
    +	__u8 reserved2 : 6;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/**
    + * @brief Removable Medium: Loading Mechanism Types
    + */
    +enum cdf_removable_media_lmt {
    +	CDF_LMT__CADDY_SLOT_TYPE,
    +	CDF_LMT__TRAY_TYPE,
    +	CDF_LMT__POP_UP_TYPE,
    +	CDF_LMT__RESERVED1,
    +	CDF_LMT__EMBEDDED_INDIVIDUALLY,
    +	CDF_LMT__EMBEDDED_MAGAZINE,
    +	CDF_LMT__RESERVED2,
    +};
    +
    +/**
    + * @brief Removable Medium Feature (0003h)
    + *
    + * This Feature identifies a Drive that has a medium that is removable.
    + * Media shall be considered removable if it is possible to remove it
    + * from the loaded position, i.e., a single mechanism changer, even if
    + * the media is captive to the changer.
    + *
    + * The Drive shall generate Events for media changes.
    + * Event Notification Class 4 (Media Events) shall be supported. This
    + * includes reporting user requests to load/eject the medium.
    + */
    +struct cdf_removable_medium {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +	/* The Additional Length field shall be set to 4. */
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	/**
    +	 * The Loading Mechanism Type field shall be set according to
    +	 * @enum cdf_removable_media_lmt
    +	 */
    +	__u8 mechanism : 3;
    +	/**
    +	 * If the Load bit is set to zero, the Drive is unable to load
    +	 * the medium or cartridge via the START STOP UNIT command with
    +	 * the LoEj bit set to one, e.g. the tray type loading mechanism
    +	 * that is found in many portable PCs.
    +	 * If the Load bit is set to one, the Drive is able to load the
    +	 * medium or cartridge.
    +	 */
    +	__u8 load : 1;
    +	/**
    +	 * The Eject bit, when set to zero, indicates that the device is
    +	 * unable to eject the medium or magazine via the normal START STOP UNIT
    +	 * command with the LoEj bit set.
    +	 * When set to one, indicates that the device is able to eject
    +	 * the medium or magazine.
    +	 */
    +	__u8 eject : 1;
    +	/**
    +	 * The Pvnt Jmpr bit, when set to zero, shall indicate that the
    +	 * Prevent Jumper is present.
    +	 * When set to one, the Prevent Jumper is not present.
    +	 * The Pvnt Jmpr bit shall not change state, even if the physical
    +	 * jumper is added or removed during operation.
    +	 */
    +	__u8 prvnt_jmp : 1;
    +	__u8 reserved2 : 1;
    +	/**
    +	 * If Lock is set to zero, there is no locking mechanism for locking
    +	 * the medium into the Drive. If Lock is set to one, the Drive is
    +	 * capable of locking the media into the Drive.
    +	 */
    +	__u8 lock : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 lock : 1;
    +	__u8 reserved2 : 1;
    +	__u8 prvnt_jmp : 1;
    +	__u8 eject : 1;
    +	__u8 load : 1;
    +	__u8 mechanism : 3;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/**
    + * @brief Random Readable Feature (0010h)
    + *
    + * This Feature identifies a Drive that is able to read data from logical
    + * blocks referenced by Logical Block Addresses, but not requiring that
    + * either the addresses or the read sequences occur in any particular order.
    + */
    +struct cdf_random_readable {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +	/* The Additional Length field shall be set to 8. */
    +	__u8 length;
    +	/**
    +	 * The Logical Block Size shall be set to the number of bytes per
    +	 * logical block.
    +	 */
    +	__be32 block_size;
    +	/**
    +	 * The Blocking field shall indicate the number of logical blocks per
    +	 * device readable unit.
    +	 * If there is more than one Blocking on the medium possible,
    +	 * the Blocking field shall be set to zero.
    +	 */
    +	__be16 blocking;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 7;
    +	/**
    +	 * The PP (Page Present) bit, when set to zero, shall indicate that
    +	 * the Read/Write Error Recovery mode page may not be present.
    +	 * When set to one, shall indicate that the Read/Write Error Recovery
    +	 * mode page is present.
    +	 */
    +	__u8 pp : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 pp : 1;
    +	__u8 reserved2 : 7;
    +#endif
    +
    +	__u8 reserved3;
    +} __packed;
    +
    +/*
    + * Multi-read Feature (001Dh)
    + * The Drive shall conform to the OSTA Multi-Read
    + * specification 1.00, with the exception of CD Play
    + * capability (the CD Audio Feature is not required).
    + */
    +struct cdf_multi_read {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +} __packed;
    +
    +/*
    + * CD Read Feature (001Eh)
    + * This Feature identifies a Drive that is able to read
    + * CD specific information from the media and is able
    + * to read user data from all types of CD sectors.
    + */
    +struct cdf_cd_read {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +
    +	/*
    +	 * If DAP is set to one, the READ CD and READ CD MSF
    +	 * commands support the DAP bit in bit 1, byte 1
    +	 * of the CDB.
    +	 */
    +	__u8 dap : 1;
    +	__u8 reserved2 : 5;
    +
    +	/*
    +	 * The C2 Flags, when set to one, indicates the Drive
    +	 * supports the C2 Error Pointers.
    +	 * When set to zero the Drive does not support
    +	 * C2 Error Pointers.
    +	 */
    +	__u8 c2flags : 1;
    +	/*
    +	 * The CD-Text bit, when set to one, indicates the Drive
    +	 * supports Format Code 5h of the READ TOC/PMA/ATIP
    +	 * command.
    +	 * When set to zero, CD-Text is not supported.
    +	 */
    +	__u8 cdtext : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 cdtext : 1;
    +	__u8 c2flags : 1;
    +	__u8 reserved2 : 5;
    +	__u8 dap : 1;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/*
    + * DVD Read Feature (001Fh)
    + * This Feature identifies a Drive that is able to read DVD
    + * specific information from the media.
    + */
    +struct cdf_dvd_read {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 7;
    +	/*
    +	 * If MULTI110 is set to one, the Drive shall
    +	 * be compliant with the DVD Multi Drive Read-only
    +	 * specifications as defined in [DVD-Ref8].
    +	 */
    +	__u8 multi110 : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 multi110 : 1;
    +	__u8 reserved2 : 7;
    +#endif
    +	__u8 reserved3;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved4 : 6;
    +	/*
    +	 * If the DVD-RW Dual Layer (Dual-RW) bit is set to one,
    +	 * the Drive is able to read DVD-RW DL media that has the
    +	 * Complete state.
    +	 * If the Dual-RW bit is set to zero, the Drive is unable
    +	 * to read the DVD-RW DL media.
    +	 */
    +	__u8 dualrw : 1;
    +	/*
    +	 * If the DVD-R Dual Layer (Dual-R) bit is set to one,
    +	 * the Drive shall support reading all recording modes
    +	 * (i.e., Sequential recording and Layer Jump recording modes)
    +	 * of DVD-R DL discs.
    +	 * The Drive shall support Remapping on DVD-R DL discs.
    +	 */
    +	__u8 dualr : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 dualr : 1;
    +	__u8 dualrw : 1;
    +	__u8 reserved4 : 6;
    +#endif
    +
    +	__u8 reserved5;
    +} __packed;
    +
    +/**
    + * @brief DVD+R Feature (002Bh)
    + * The presence of the DVD+R Feature indicates that the Drive is
    + * capable of reading a recorded DVD+R disc that is written according
    + * to [DVD+Ref1].
    + * Specifically, this includes the capability of reading DCBs.
    + */
    +struct cdf_dvd_plus_r {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 7;
    +	/**
    +	 * If the Write bit is set to one, then the Drive is also capable
    +	 * of writing DVD+R discs according to [DVD+Ref1].
    +	 */
    +	__u8 write : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 write : 1;
    +	__u8 reserved2 : 7;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/**
    + * @brief CD Track at Once Feature (002Dh)
    + * This Feature identifies a Drive that is able to write data to
    + * a CD track.
    + */
    +struct cdf_cd_track_at_once {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 1;
    +	/**
    +	 * The BUF bit, if set to 1, shall indicate that the Drive
    +	 * is capable of zero loss linking.
    +	 */
    +	__u8 buf : 1;
    +	__u8 reserved1 : 1;
    +	/**
    +	 * The R-W Raw bit, if set to 1, shall indicate that the Drive
    +	 * supports writing R-W Sub code in the Raw mode.
    +	 * The R-W Sub-code bit shall be set if this bit is set.
    +	 */
    +	__u8 rw_raw : 1;
    +	/**
    +	 * The R-W Pack bit, if set to 1, shall indicate that the Drive
    +	 * supports writing R-W Sub code in the Packed mode.
    +	 * The R-W Sub-code bit shall be set if this bit is set.
    +	 */
    +	__u8 rw_pack : 1;
    +	/**
    +	 * The Test Write bit indicates that the Drive is able to
    +	 * perform test writes.
    +	 */
    +	__u8 test_write : 1;
    +	/**
    +	 * The CD-RW bit indicates support for overwriting a Track at
    +	 * Once track with another.
    +	 */
    +	__u8 cd_rw : 1;
    +	/**
    +	 * The R-W Sub-code bit indicates that the Drive is able to
    +	 * record the R-W Sub-channels with user supplied data.
    +	 */
    +	__u8 rw_subcode : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 rw_subcode : 1;
    +	__u8 cd_rw : 1;
    +	__u8 test_write : 1;
    +	__u8 rw_pack : 1;
    +	__u8 rw_raw : 1;
    +	__u8 reserved3 : 1;
    +	__u8 buf : 1;
    +	__u8 reserved2 : 1;
    +#endif
    +
    +	__u8 reserved4;
    +	/**
    +	 * The data type references to the
    +	 * &#34;Incremental Streaming Writable Feature&#34;
    +	 */
    +	__be16 data_type_supported;
    +} __packed;
    +
    +/**
    + * @brief BD Read Feature (0040h)
    + * This Feature identifies a Drive that is able to read control
    + * structures and user data from the BD disc.
    + */
    +struct cdf_bd_read {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +	__u8 reserved2[4];
    +	/**
    +	 * If the Version K bit (K = 0...15) of the Class M (M = 0...3)
    +	 * bit map is set to zero, the Drive claims no read capabilities
    +	 * for BD-R(E)(ROM) discs of Class M and Version K.
    +	 * If the Version K bit of Class M is set to one, the Drive is
    +	 * able to read BD-RE discs of class M and Version K.
    +	 *
    +	 */
    +
    +	/* Class M (M = 0..3) BD-RE Read Support */
    +	__be16 class0_bdre_read_support;
    +	__be16 class1_bdre_read_support;
    +	__be16 class2_bdre_read_support;
    +	__be16 class3_bdre_read_support;
    +	/* Class M (M = 0..3) BD-R Read Support */
    +	__be16 class0_bdr_read_support;
    +	__be16 class1_bdr_read_support;
    +	__be16 class2_bdr_read_support;
    +	__be16 class3_bdr_read_support;
    +	/* Class M (M = 0..3) BD-ROM Read Support */
    +	__be16 class0_bdrom_read_support;
    +	__be16 class1_bdrom_read_support;
    +	__be16 class2_bdrom_read_support;
    +	__be16 class3_bdrom_read_support;
    +} __packed;
    +
    +/**
    + * @brief Power Management Feature (0100h)
    + * This Feature identifies a Drive that is able to perform Host and
    + * Drive directed power management.
    + */
    +struct cdf_power_mgmt {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +} __packed;
    +
    +/**
    + * @brief Real Time Streaming Feature (0107h)
    + * This Feature identifies a Drive that is able to perform reading
    + * and writing within Host specified (and Drive verified) performance
    + * ranges. This Feature also indicates whether the Drive supports the
    + * Stream playback operation.
    + */
    +struct cdf_rt_streaming {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	__u8 length;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved2 : 3;
    +	/**
    +	 * The Read Buffer Capacity Block (RBCB) bit indicates that the
    +	 * Drive supports the READ_BUFFER_CAPACITY command and its Block
    +	 * bit.
    +	 */
    +	__u8 rbcb : 1;
    +	/**
    +	 * The Set CD Speed (SCS) bit of one indicates that the Drive
    +	 * supports the SET_CD_SPEED command. Otherwise, the Drive does not
    +	 * support the SET_CD_SPEED command.
    +	 */
    +	__u8 scs : 1;
    +	/**
    +	 * The mode page 2A (MP2A) bit of one indicates that the MM
    +	 * Capabilities &#38; Mechanical Status mode page (2Ah) with the Drive
    +	 * Write Speed Performance Descriptor Blocks is supported.
    +	 * Otherwise, the MM Capabilities &#38; Mechanical Status mode
    +	 * page (2Ah), with the Drive Write Speed Performance Descriptor
    +	 * Blocks are not supported by the Drive.
    +	 */
    +	__u8 mp2a : 1;
    +	/**
    +	 * A Write Speed Performance Descriptor (WSPD) bit of one indicates
    +	 * that the Drive supports the Write Speed (Type field = 03h) data
    +	 * of GET PERFORMANCE command and the WRC field of SET STREAMING
    +	 * command. This bit shall be set to one, if Drive supports writing
    +	 * speed selection.
    +	 */
    +	__u8 wspd : 1;
    +	/**
    +	 * A Stream Writing (SW) bit of one indicates that the Drive
    +	 * supports the Stream recording operation. A SW bit of zero
    +	 * indicates that the Drive may not support the Stream recording
    +	 * operation.
    +	 */
    +	__u8 sw : 1;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 sw : 1;
    +	__u8 wspd : 1;
    +	__u8 mp2a : 1;
    +	__u8 scs : 1;
    +	__u8 rbcb : 1;
    +	__u8 reserved2 : 3;
    +#endif
    +
    +	__u8 reserved3[3];
    +} __packed;
    +
    +/**
    + * @brief Disc Control Blocks (DCBs) Feature (010Ah)
    + *
    + * This Feature identifies a Drive that is able to read and/or write
    + * DCBs from or to the media.
    + */
    +struct cdf_dcbs {
    +	__be16 code;
    +
    +	struct cdb_ft_vpc_byte vpc;
    +
    +	/**
    +	 * The Additional Length field shall be set to N * 4, where n is
    +	 * the number of Supported DCB entries. The Supported DCB entry
    +	 * n fields shall each contain the Content Descriptor of a
    +	 * supported DCB.
    +	 * Entries shall be sorted in ascending order.
    +	 */
    +	__u8 length;
    +
    +	/**
    +	 * Non supported read and/or write the DCBs blocks.
    +	 */
    +	__be32 supported_dcb_entry[0];
    +};
    +
    +/*
    + * feature codes list
    + */
    +
    +/* A list of all Profiles supported by the Drive*/
    +#define CDF_PROFILE_LIST_CODE 0x0000
    +/* Mandatory behavior for all devices */
    +#define CDF_CORE 0x0001
    +
    +#define CDF_MORPHING_CODE 0x0002
    +/* The medium may be removed from the device */
    +#define CDF_REMOVEBLE_MEDIA 0x0003
    +#define CDF_RANDOM_READ 0x0010
    +/* The Drive is able to read all CD media types; based on OSTA MultiRead */
    +#define CDF_MULTI_READ 0x001D
    +/* The ability to read CD specific structures */
    +#define CDF_CD_READ 0x001E
    +/* The ability to read DVD specific structures*/
    +#define CDF_DVD_READ 0x001F
    +/* Write support for randomly addressed writes */
    +#define CDF_RWRT 0x0020
    +/* Write support for sequential recording */
    +#define CDF_INC_STREAM_WR 0x0021
    +/* Hardware Defect Management */
    +#define CDF_HWDM 0x0024
    +/* The ability to recognize and read and optionally write MRW formatted media */
    +#define CDF_MRW 0x0028
    +/* The ability to read DVD+R recorded media formats */
    +#define CDF_DVD_R 0x002B
    +/* Ability to write CD with Track at Once recording */
    +#define CDF_CD_TRACK_ONCE 0x002D
    +/* The ability to read control structures and user data from a BD disc */
    +#define CDF_BD_READ 0x0040
    +/* The ability to write control structures and user data to certain BD discs */
    +#define CDF_BD_WRITE 0x0041
    +/* Host and device directed power management */
    +#define CDF_POWER_MGMT 0x0100
    +/* Ability to perform DVD CSS/CPPM authentication and RPC */
    +#define CDF_DVD_CSS 0x0106
    +/* Ability to read and write using Host requested performance parameters */
    +#define CDF_REAL_TIME_STREAM 0x0107
    +/* The ability to read and/or write DCBs*/
    +#define CDF_DCBS 0x010A
    +
    </span> /**
      * The READ TOC/PMA/ATIP format field values
      */
    -- 
    2.32.0
    
    
    <a
    href=#md657bf4dd0d02f809976e2561e2c45855edcc57d
    id=ed657bf4dd0d02f809976e2561e2c45855edcc57d>^</a> <a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-6-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#rd657bf4dd0d02f809976e2561e2c45855edcc57d>16+ messages in thread</a></pre><hr><pre><a
    href=#ef9201ae82cadb63aa148811fdeae78d3d4c1fa16
    id=mf9201ae82cadb63aa148811fdeae78d3d4c1fa16>*</a> <b>[PATCH 6/6] FMS: Add SCSI Read Disc Information command.</b>
           [not found] &lt;<a
    href=#r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
                       ` <a
    href=#rd657bf4dd0d02f809976e2561e2c45855edcc57d>(4 preceding siblings ...)</a>
      2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d">[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
    <b>@ 2021-06-26 21:18 ` Igor Kononenko</b>
      <a
    href=#rf9201ae82cadb63aa148811fdeae78d3d4c1fa16>5 siblings, 0 replies; 16+ messages in thread</a>
    From: Igor Kononenko @ 2021-06-26 21:18 UTC (<a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/">permalink</a> / <a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/raw">raw</a>)
      To: Felipe Balbi, Greg Kroah-Hartman, James E.J. Bottomley,
        Martin K. Petersen, Jens Axboe
      Cc: openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626211906">linux-usb</a>, <a
    href="../../../lkml/?t=20210626211906">linux-kernel</a>, <a
    href="../../../linux-scsi/?t=20210626211906">linux-scsi</a>
    
    Adds the SCSI Read Disc Information command, which should be given for
    multimedia device consumers to retrieve the DVD/BD disk information
    about:
    * Total tracks contained at the disc Total and active sessions Border
    * status(incomplete, damaged, etc.)
    This information is wanted for supporting the DVD-ROM and BD-ROM
    devices.
    
    End-user-impact: Now, multimedia device consumers have a way to retrieve
                     the multimedia disk information.
    
    Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    ---
     <a
    id=iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    href=#Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>drivers/usb/gadget/function/f_mass_storage.c</a> |  37 ++++
     <a
    id=iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h
    href=#Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h>include/scsi/scsi_proto.h</a>                    |   1 +
     <a
    id=iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    href=#Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>include/uapi/linux/cdrom.h</a>                   | 195 +++++++++++++++++--
     3 files <a href="#ef9201ae82cadb63aa148811fdeae78d3d4c1fa16">changed</a>, 212 insertions(+), 21 deletions(-)
    
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c
    id=Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1drivers:usb:gadget:function:f_mass_storage.c>diff</a> --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
    index 7e736e5594f9..d3d8a806b5e6 100644
    --- a/drivers/usb/gadget/function/f_mass_storage.c
    +++ b/drivers/usb/gadget/function/f_mass_storage.c
    </span><span
    class="hunk">@@ -1932,6 +1932,40 @@ static void send_status(struct fsg_common *common)
    </span> 	return;
     }
     
    <span
    class="add">+static int do_read_disc_info(struct fsg_common *common, struct fsg_buffhd *bh)
    +{
    +	struct fsg_lun *curlun = common-&gt;curlun;
    +	struct cdb_disc_info *cdb = (struct cdb_disc_info *)common-&gt;cmnd;
    +	disc_information *info = (disc_information *)bh-&gt;buf;
    +
    +	if (cdb-&gt;type != DISC_TYPE_STANDARD) {
    +		LERROR(curlun,
    +		       &#34;Unsupported disc information type(%02Xh) requested\n&#34;,
    +		       cdb-&gt;type);
    +		return -EINVAL;
    +	}
    +	memset(info, 0, sizeof(disc_information));
    +	info-&gt;disc_information_length = cpu_to_be16(
    +		sizeof(*info) - sizeof(info-&gt;disc_information_length));
    +
    +	info-&gt;border_status = DISC_LAST_SESS_COMPLETE;
    +	info-&gt;disc_status = DISC_STATUS_FINALIZED;
    +
    +	/* We only support one session per disk */
    +	info-&gt;n_first_track = 1;
    +	info-&gt;n_sessions_lsb = 1;
    +	info-&gt;first_track_lsb = 1;
    +	info-&gt;last_track_lsb = 1;
    +
    +	/* Setting the unrestricted use because we only support (CD/DVD/BD)-ROM */
    +	info-&gt;uru = 1;
    +
    +	info-&gt;disc_type = DISC_FIELD_DA_ROM;
    +
    +	common-&gt;data_size_to_handle = sizeof(*info);
    +	return 0;
    +}
    +
    </span> /**
      * Attempts to guess medium type by looking at the length of the disc layout.
      */
    <span
    class="hunk">@@ -2253,6 +2287,8 @@ static struct cdb_command_check cdb_checker_table[] = {
    </span> 	{ CDB_REG_CHECKER(TEST_UNIT_READY, 6, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
                   0x0000, MEDIUM_REQUIRED) },
     
    <span
    class="add">+	{ CDB_REG_NO_CHECKER(READ_DISC_INFORMATION, CDB_SIZE_FIELD_7,
    +			     DATA_DIR_TO_HOST, MEDIUM_REQUIRED) },
    </span> 	{ CDB_REG_NO_CHECKER(GET_CONFIGURATION, CDB_SIZE_FIELD_7,
                      DATA_DIR_TO_HOST, MEDIUM_REQUIRED) },
     
    <span
    class="hunk">@@ -2286,6 +2322,7 @@ static struct cdb_handler cdb_handlers_table[] = {
    </span> 	{ CDB_REG_HANDLER(SYNCHRONIZE_CACHE, &#38;do_synchronize_cache) },
         { CDB_REG_HANDLER(TEST_UNIT_READY, NULL) },
     
    <span
    class="add">+	{ CDB_REG_HANDLER_BUFFHD(READ_DISC_INFORMATION, &#38;do_read_disc_info) },
    </span> 	{ CDB_REG_HANDLER_BUFFHD(GET_CONFIGURATION, &#38;do_get_configuration) },
         /*
          * Although optional, this command is used by MS-Windows.  We
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h
    id=Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:scsi:scsi_proto.h>diff</a> --git a/include/scsi/scsi_proto.h b/include/scsi/scsi_proto.h
    index 6b2a8ee1f0a3..6728fcbd73e4 100644
    --- a/include/scsi/scsi_proto.h
    +++ b/include/scsi/scsi_proto.h
    </span><span
    class="hunk">@@ -77,6 +77,7 @@
    </span> #define GET_EVENT_STATUS_NOTIFICATION 0x4a
     #define LOG_SELECT            0x4c
     #define LOG_SENSE             0x4d
    <span
    class="add">+#define READ_DISC_INFORMATION 0x51
    </span> #define XDWRITEREAD_10        0x53
     #define MODE_SELECT_10        0x55
     #define RESERVE_10            0x56
    <span
    class="head"><a
    href=#iZ2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h
    id=Z2e.:..:20210626211820.107310-7-i.kononenko::40yadro.com:1include:uapi:linux:cdrom.h>diff</a> --git a/include/uapi/linux/cdrom.h b/include/uapi/linux/cdrom.h
    index 442693fdc059..460377e1a532 100644
    --- a/include/uapi/linux/cdrom.h
    +++ b/include/uapi/linux/cdrom.h
    </span><span
    class="hunk">@@ -816,51 +816,204 @@ struct rwrt_feature_desc {
    </span> 	__u8 reserved3;
     };
     
    <span
    class="add">+/* Disc Information Data Types */
    +#define DISC_TYPE_STANDARD			(0x00U)
    +#define DISC_TYPE_TRACK				(0x01U)
    +#define DISC_TYPE_POW				(0x02U)
    +
    +/* Disc Status */
    +#define DISC_STATUS_EMPTY			(0x00U)
    +#define DISC_STATUS_INCOMPLETE		(0x01U)
    +#define DISC_STATUS_FINALIZED		(0x02U)
    +#define DISC_STATUS_OTHER			(0x03U)
    +
    +/* State of Last Session */
    +#define DISC_LAST_SESS_EMPTY		(0x00U)
    +#define DISC_LAST_SESS_INCOMPLETE	(0x01U)
    +#define DISC_LAST_SESS_DAMAGED		(0x02U)
    +#define DISC_LAST_SESS_COMPLETE		(0x03U)
    +
    +/* Background Format Status Codes */
    +#define DISC_BACK_FMT_NEITHER		(0x00U)
    +#define DISC_BACK_FMT_STARTED		(0x01U)
    +#define DISC_BACK_FMT_PROGRESS		(0x02U)
    +#define DISC_BACK_FMT_COMPLETED		(0x03U)
    +
    +/* Disc Type Field */
    +#define DISC_FIELD_DA_ROM			(0x00U)
    +#define DISC_FIELD_I				(0x10U)
    +#define DISC_FIELD_ROM_XA			(0x20U)
    +#define DISC_FIELD_UNDEF			(0xFFU)
    +
    +/**
    + * @brief The READ DISC INFORMATION CDB(0051h)
    + * The READ DISC INFORMATION command allows the Host to request information about
    + * the currently mounted MM disc.
    + */
    +struct cdb_disc_info {
    +	__u8 code;
    +
    +#if defined(__BIG_ENDIAN_BITFIELD)
    +	__u8 reserved1 : 5;
    +	/**
    +	 * When a disc is present, Data Type defines the specific information requested
    +	 */
    +	__u8 type : 3;
    +#elif defined(__LITTLE_ENDIAN_BITFIELD)
    +	__u8 type : 3;
    +	__u8 reserved1 : 5;
    +#endif
    +
    +	__u8 reserved2[5];
    +
    +	__be16 length;
    +
    +	__u8 control;
    +}  __packed;
    +
    </span> typedef struct {
         __be16 disc_information_length;
     #if defined(__BIG_ENDIAN_BITFIELD)
    <span
    class="del">-	__u8 reserved1			: 3;
    -        __u8 erasable			: 1;
    -        __u8 border_status		: 2;
    -        __u8 disc_status		: 2;
    </span><span
    class="add">+	/**
    +	 * The Disc Information Data Type field shall be set to the reported
    +	 * Disc Information Type
    +	 */
    +	__u8 info_data_type : 3;
    +	/**
    +	 * The Erasable bit, when set to one, indicates that CD-RW, DVD-RAM, DVD-RW, DVD+RW,
    +	 * HD DVD-RAM, or BD-RE media is present and the Drive is capable of writing the media.
    +	 * If the Erasable bit is set to zero, then either the medium is not erasable or the
    +	 * Drive is unable to write the media.
    +	 */
    +	__u8 erasable : 1;
    +	/**
    +	 * The State of Last Session field specifies the recorded state of the last
    +	 * session, regardless of the number of sessions on the disc.
    +	 */
    +	__u8 border_status : 2;
    +	/* The Disc Status field indicates the recorded status of the disc */
    +	__u8 disc_status : 2;
    </span> #elif defined(__LITTLE_ENDIAN_BITFIELD)
    <span
    class="del">-        __u8 disc_status		: 2;
    -        __u8 border_status		: 2;
    -        __u8 erasable			: 1;
    -	__u8 reserved1			: 3;
    </span><span
    class="add">+	__u8 disc_status : 2;
    +	__u8 border_status : 2;
    +	__u8 erasable : 1;
    +	__u8 info_data_type : 3;
    </span> #else
     #error &#34;Please fix &lt;asm/byteorder.h&gt;&#34;
     #endif
    <span
    class="add">+	/**
    +	 * The Number of First Track on Disc is the track number of the Logical Track that
    +	 * contains LBA 0
    +	 */
    </span> 	__u8 n_first_track;
         __u8 n_sessions_lsb;
    <span
    class="add">+	/**
    +	 * First Track Number in Last Session (bytes 5 &#38; 10) is the track number of the
    +	 * first Logical Track in the last session.
    +	 * This includes the incomplete logical track.
    +	 */
    </span> 	__u8 first_track_lsb;
    <span
    class="add">+	/**
    +	 * Last Track Number in Last Session (bytes 6 &#38; 11) is the track number of the last
    +	 * Logical Track in the last session.
    +	 * This includes the incomplete logical track.
    +	 */
    </span> 	__u8 last_track_lsb;
     #if defined(__BIG_ENDIAN_BITFIELD)
    <span
    class="del">-	__u8 did_v			: 1;
    -        __u8 dbc_v			: 1;
    -        __u8 uru			: 1;
    -        __u8 reserved2			: 2;
    -	__u8 dbit			: 1;
    -	__u8 mrw_status			: 2;
    </span><span
    class="add">+	/**
    +	 * The DID_V (Disc ID Valid) bit, when set to one, indicates that the Disc
    +	 * Identification field is valid
    +	 */
    +	__u8 did_v : 1;
    +	/**
    +	 * The DBC_V (Disc Bar Code Valid bit, when set to one, indicates that the Disc Bar
    +	 * Code field (bytes 24 through 31) is valid
    +	 */
    +	__u8 dbc_v : 1;
    +	/**
    +	 * The URU (Unrestricted Use Disc) bit may be zero for special use CD-R, CD-RW,
    +	 * or DVD-R, medium.
    +	 * For all other media types, URU shall be set to one. When URU is zero, the mounted
    +	 * disc is defined for restricted use.
    +	 */
    +	__u8 uru : 1;
    +	/**
    +	 * DAC_V indicates the validity of the Disc Application Code in byte 32. If DAC_V is
    +	 * set to zero, then the Disc Application Code is not valid. If DAC_V is set to one,
    +	 * the Disc Application Code is valid.
    +	 */
    +	__u8 dac_v: 1;
    +	__u8 reserved2 : 1;
    +	/**
    +	 * If the disc is MRW formatted or MRW formatting (state = 01b, 10b, or 11b),
    +	 * then bit 2 of byte 7 (Dbit) is a copy of the &#8220;dirty bit&#8221; from the defect table.
    +	 * If Dbit is set to zero, then the MRW structures are current.
    +	 * If Dbit is set to one, then the MRW structures may not be current.
    +	 * When BG format status = 00b, Dbit shall be set to zero.
    +	 */
    +	__u8 dbit : 1;
    +	/**
    +	 * The BG format status is the background format status of the mounted disc.
    +	 * Drives that report the Formattable Feature and either the MRW Feature or the DVD+RW
    +	 * Feature, or both are required to implement Background format.
    +	 * For all other Drives, this field shall be @param DISC_BACK_FMT_NEITHER.
    +	 */
    +	__u8 mrw_status : 2;
    </span> #elif defined(__LITTLE_ENDIAN_BITFIELD)
    <span
    class="del">-	__u8 mrw_status			: 2;
    -	__u8 dbit			: 1;
    -        __u8 reserved2			: 2;
    -        __u8 uru			: 1;
    -        __u8 dbc_v			: 1;
    -	__u8 did_v			: 1;
    </span><span
    class="add">+	__u8 mrw_status : 2;
    +	__u8 dbit : 1;
    +	__u8 reserved2 : 1;
    +	__u8 dac_v: 1;
    +	__u8 uru : 1;
    +	__u8 dbc_v : 1;
    +	__u8 did_v : 1;
    </span> #endif
    <span
    class="add">+	/**
    +	 * The Disc Type field is associated only with CD media type
    +	 */
    </span> 	__u8 disc_type;
         __u8 n_sessions_msb;
         __u8 first_track_msb;
         __u8 last_track_msb;
    <span
    class="add">+
    +	/**
    +	 * For CD-R/RW, the Disc Identification number recorded in the PMA is returned.
    +	 * The Disc Identification Number is recorded in the PMA as a six-digit BCD number.
    +	 * It is returned in the Disc Information Block as a 32 bit binary integer.
    +	 * This value should be zero filled for all other media types.
    +	 */
    </span> 	__u32 disc_id;
    <span
    class="add">+	/**
    +	 * The Last Session Lead-in Start Address field is dependent on medium and
    +	 * recorded status.
    +	 */
    </span> 	__u32 lead_in;
    <span
    class="add">+	/**
    +	 * The Last Possible Lead-out Start Address field is dependent on medium and
    +	 * recorded status.
    +	 */
    </span> 	__u32 lead_out;
    <span
    class="add">+	/**
    +	 * For CD, the Disc Bar Code field contains the hexadecimal value of the bar code
    +	 * if the Drive has the ability to read Disc Bar Code and a bar code is present.
    +	 * For all other media this field should be set to zeros.
    +	 */
    </span> 	__u8 disc_bar_code[8];
    <span
    class="add">+	/**
    +	 *
    +	 */
    </span> 	__u8 reserved3;
    <span
    class="add">+	/**
    +	 * The Number of OPC Tables field is the number of OPC tables that follow this field.
    +	 * If OPC has not been determined for the currently mounted medium, the Number of
    +	 * OPC Tables field is set to zero.
    +	 * The Number of OPC Tables represents the number of disc speeds for which the OPC
    +	 * values are known.
    +	 * Since each OPC Table is 8 bytes in length, then the number of bytes that follow
    +	 * the Number of OPC Tables field is 8 x Number of OPC Tables.
    +	 */
    </span> 	__u8 n_opc;
    <span
    class="del">-} disc_information;
    </span><span
    class="add">+} __packed disc_information;
    </span> 
     typedef struct {
         __be16 track_information_length;
    -- 
    2.32.0
    
    
    <a
    href=#mf9201ae82cadb63aa148811fdeae78d3d4c1fa16
    id=ef9201ae82cadb63aa148811fdeae78d3d4c1fa16>^</a> <a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/">permalink</a> <a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/raw">raw</a> <a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/#R">reply</a> <a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/#related">related</a>	[<a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/T/#u"><b>flat</b></a>|<a
    href="../../20210626211820.107310-7-i.kononenko@yadro.com/t/#u">nested</a>] <a
    href=#rf9201ae82cadb63aa148811fdeae78d3d4c1fa16>16+ messages in thread</a></pre><hr><pre><a
    href=#eaaed19c5d26b1f62307d2d9d1215506946eab6bb
    id=maaed19c5d26b1f62307d2d9d1215506946eab6bb>*</a> <b>Re: [PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</b>
      2021-06-26 21:18 ` <a
    href="#ma4dcc8b46e33a8365a8dca614cab4b78501d241c">[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</a> Igor Kononenko
    <b>@ 2021-06-26 23:29   ` kernel test robot</b>
      2021-06-27 14:23   ` <a
    href="#m4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6">Alan Stern</a>
      <a
    href=#raaed19c5d26b1f62307d2d9d1215506946eab6bb>1 sibling, 0 replies; 16+ messages in thread</a>
    From: kernel test robot @ 2021-06-26 23:29 UTC (<a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/">permalink</a> / <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/raw">raw</a>)
      To: Igor Kononenko, Felipe Balbi, Greg Kroah-Hartman
      Cc: kbuild-all, openbmc, Igor Kononenko, <a
    href="../../../linux-usb/?t=20210626233016">linux-usb</a>, <a
    href="../../../lkml/?t=20210626233016">linux-kernel</a>
    
    <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 17714 bytes --]</a>
    
    Hi Igor,
    
    Thank you for the patch! Perhaps something to improve:
    
    [auto build test WARNING on mkp-scsi/for-next]
    [also build test WARNING on scsi/for-next linus/master v5.13-rc7 next-20210625]
    [If your patch is applied to the wrong git tree, kindly drop us a note.
    And when submitting patch, we suggest to use &#39;--base&#39; as documented in
    <a
    href="https://git-scm.com/docs/git-format-patch">https://git-scm.com/docs/git-format-patch</a>]
    
    url:    <a
    href="https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851">https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851</a>
    base:   <a
    href="https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git">https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git</a> for-next
    config: m68k-allmodconfig (attached as .config)
    compiler: m68k-linux-gcc (GCC) 9.3.0
    reproduce (this is a W=1 build):
            wget <a
    href="https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross">https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross</a> -O ~/bin/make.cross
            chmod +x ~/bin/make.cross
            # <a
    href="https://github.com/0day-ci/linux/commit/92c07dc68c51fab87517c2453d8f249c2565deed">https://github.com/0day-ci/linux/commit/92c07dc68c51fab87517c2453d8f249c2565deed</a>
            git remote add linux-review <a
    href="https://github.com/0day-ci/linux">https://github.com/0day-ci/linux</a>
            git fetch --no-tags linux-review Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851
            git checkout 92c07dc68c51fab87517c2453d8f249c2565deed
            # save the attached .config to linux build tree
            COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-9.3.0 make.cross ARCH=m68k 
    
    If you fix the issue, kindly add following tag as appropriate
    Reported-by: kernel test robot &lt;lkp@intel.com&gt;
    
    All warnings (new ones prefixed by &gt;&gt;):
    
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1948:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1948 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[6].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1948:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1948 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1950:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1950 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[7].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1950:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1950 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1952:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1952 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[8].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1952:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1952 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1973:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1973 |  { CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[17].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1973:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1973 |  { CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1975:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1975 |  { CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[18].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1975:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1975 |  { CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1977:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1977 |  { CDB_REG_CHECKER_BLK(WRITE_10, 10, CDB_SIZE_FIELD_7,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[19].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1977:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1977 |  { CDB_REG_CHECKER_BLK(WRITE_10, 10, CDB_SIZE_FIELD_7,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1979:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1979 |  { CDB_REG_CHECKER_BLK(WRITE_12, 12, CDB_SIZE_FIELD_6,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[20].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1979:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1979 |  { CDB_REG_CHECKER_BLK(WRITE_12, 12, CDB_SIZE_FIELD_6,
             |    ^~~~~~~~~~~~~~~~~~~
    --
       drivers/usb/gadget/function/f_mass_storage.c: In function &#39;invalidate_sub&#39;:
       drivers/usb/gadget/function/f_mass_storage.c:1084:16: warning: variable &#39;rc&#39; set but not used [-Wunused-but-set-variable]
        1084 |  unsigned long rc;
             |                ^~
       drivers/usb/gadget/function/f_mass_storage.c: At top level:
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1948:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1948 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[6].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1948:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1948 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1950:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1950 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[7].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1950:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1950 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1952:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1952 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[8].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1952:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1952 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1973:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1973 |  { CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[17].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1973:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1973 |  { CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1975:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1975 |  { CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[18].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1975:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1975 |  { CDB_REG_CHECKER_BLK(WRITE_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_FROM_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1977:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1977 |  { CDB_REG_CHECKER_BLK(WRITE_10, 10, CDB_SIZE_FIELD_7,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[19].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1977:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1977 |  { CDB_REG_CHECKER_BLK(WRITE_10, 10, CDB_SIZE_FIELD_7,
             |    ^~~~~~~~~~~~~~~~~~~
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:310:23: warning: initialized field overwritten [-Woverride-init]
    </span>     310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1979:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1979 |  { CDB_REG_CHECKER_BLK(WRITE_12, 12, CDB_SIZE_FIELD_6,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:310:23: note: (near initialization for &#39;cdb_checker_table[20].do_check_command&#39;)
         310 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:1979:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        1979 |  { CDB_REG_CHECKER_BLK(WRITE_12, 12, CDB_SIZE_FIELD_6,
             |    ^~~~~~~~~~~~~~~~~~~
    
    
    vim +310 drivers/usb/gadget/function/f_mass_storage.c
    
       242	
       243	/**
       244	 * @brief The handler of incoming CDB command
       245	 * @param cmd		- SCSI command number
       246	 * @param callback	- The callback of handle the incoming command
       247	 */
       248	#define CDB_REG_HANDLER(cmd, callback)                                         \
       249		.command = (cmd), .do_command = (callback),                            \
       250		.type = CDB_HANDLER_COMMON, .name = (#cmd)
       251	
       252	/**
       253	 * @brief The handler of incoming CDB command
       254	 * @param cmd		- SCSI command nubmer with fsg buffhd
       255	 * @param callback	- The callback of handle the incoming command
       256	 */
       257	#define CDB_REG_HANDLER_BUFFHD(cmd, callback)                                  \
       258		.command = (cmd), .do_command_with_buffhd = (callback),                \
       259		.type = CDB_HANDLER_FSG_BUFFHD, .name = (#cmd)
       260	
       261	/**
       262	 * @see CDB_REG_CHECKER_DS
       263	 * @details Register CDB command without additional check handler.
       264	 */
       265	#define CDB_REG_NO_CHECKER(cmd, si, dir, req)                                  \
       266		.command = (cmd), .direction = (dir), .size_index = (si),              \
       267		.medium_required = (req), .do_check_command = NULL,
       268	
       269	/**
       270	 * @brief Register the CDB command checker, which checks an incoming command
       271	 * by specified criteria.
       272	 * This validator will take care of the specified data size (DS)
       273	 *
       274	 * @param cmd	- SCSI command nubmer
       275	 * @param s		- CDB command size in bytes
       276	 * @param si	- The CDB command might have the recommended response size.
       277	 * This field indicates the size field index in the input CDB command
       278	 * buffer
       279	 * @param dir	- Direction of data transfer of requested CDB command
       280	 * @param mask  - Mask of relevant bytes in the input command buffer.
       281	 * The ordinal number of a bit in the mask indicates that a byte in the
       282	 * CDB command buffer might be present.
       283	 * If that ordinal number bit equals zero, only a zero value must be
       284	 * present in this original byte.
       285	 * @param req	- Indicates that medium MUST be present or might be optional
       286	 * @param ds	- If @param SI member is equal to @enum CDB_SIZE_MANUAL, than this
       287	 * field indicates the custom response buffer size
       288	 */
       289	#define CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, ds)                     \
       290		.command = (cmd), .size = (s), .size_index = (si), .direction = (dir), \
       291		.valid_bytes_bitmask = (mask), .medium_required = (req),               \
       292		.data_size_manual = (ds), .do_check_command = &#38;check_command
       293	
       294	/**
       295	 * @see CDB_REG_CHECKER_DS
       296	 * @details The data size is zero.
       297	 * This macro can&#39;t be used with the @enum CDB_SIZE_MANUAL
       298	 */
       299	#define CDB_REG_CHECKER(cmd, s, si, dir, mask, req)                            \
       300		CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, 0)
       301	
       302	/**
       303	 * @see CDB_REG_CHECKER_DS
       304	 * @details The checker which registried by this macros will validate the input
       305	 * data size in blocks.
       306	 * Block size specified by MSF interface type, in the curlun-&gt;blksize.
       307	 */
       308	#define CDB_REG_CHECKER_BLK(cmd, s, si, dir, mask, req)                        \
       309		CDB_REG_CHECKER_DS(cmd, s, si, dir, mask, req, 0),                     \
     &gt; 310			.do_check_command = &#38;check_command_size_in_blocks
       311	
    
    ---
    0-DAY CI Kernel Test Service, Intel Corporation
    <a
    href="https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org">https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org</a>
    
    <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/2-a.bin">[-- Attachment #2: .config.gz --]
    [-- Type: application/gzip, Size: 60468 bytes --]</a>
    
    <a
    href=#maaed19c5d26b1f62307d2d9d1215506946eab6bb
    id=eaaed19c5d26b1f62307d2d9d1215506946eab6bb>^</a> <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/">permalink</a> <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/raw">raw</a> <a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/#R">reply</a>	[<a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/T/#u"><b>flat</b></a>|<a
    href="../../202106270758.1Svs5mlo-lkp@intel.com/t/#u">nested</a>] <a
    href=#raaed19c5d26b1f62307d2d9d1215506946eab6bb>16+ messages in thread</a></pre><hr><pre><a
    href=#e31ec12223279c2669d001a846804b3ce28dda048
    id=m31ec12223279c2669d001a846804b3ce28dda048>*</a> <b>Re: [PATCH 5/6] FMS: Add the SCSI Get Configuration command.</b>
      2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d">[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
    <b>@ 2021-06-27  0:44   ` kernel test robot</b>
      2021-06-27  4:42   ` <a
    href="#md17f3ece942d5fa5c6d04d837a76c9938262a044">kernel test robot</a>
      2021-06-28  9:53   ` <a
    href="#mf92cecbdbd7f078aafb77c93f35e3f89b1b3525f">Christoph Hellwig</a>
      <a
    href=#r31ec12223279c2669d001a846804b3ce28dda048>2 siblings, 0 replies; 16+ messages in thread</a>
    From: kernel test robot @ 2021-06-27  0:44 UTC (<a
    href="../../202106270815.ikppB5sB-lkp@intel.com/">permalink</a> / <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/raw">raw</a>)
      To: Igor Kononenko, Jens Axboe, Felipe Balbi, Greg Kroah-Hartman,
        James E.J. Bottomley, Martin K. Petersen
      Cc: kbuild-all, openbmc, Igor Kononenko, <a
    href="../../../linux-ide/?t=20210627004518">linux-ide</a>, <a
    href="../../../lkml/?t=20210627004518">linux-kernel</a>,
        <a
    href="../../../linux-usb/?t=20210627004518">linux-usb</a>
    
    <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 16918 bytes --]</a>
    
    Hi Igor,
    
    Thank you for the patch! Perhaps something to improve:
    
    [auto build test WARNING on mkp-scsi/for-next]
    [also build test WARNING on scsi/for-next linus/master balbi-usb/testing/next v5.13-rc7 next-20210625]
    [If your patch is applied to the wrong git tree, kindly drop us a note.
    And when submitting patch, we suggest to use &#39;--base&#39; as documented in
    <a
    href="https://git-scm.com/docs/git-format-patch">https://git-scm.com/docs/git-format-patch</a>]
    
    url:    <a
    href="https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851">https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851</a>
    base:   <a
    href="https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git">https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git</a> for-next
    config: powerpc-randconfig-r035-20210627 (attached as .config)
    compiler: powerpc64-linux-gcc (GCC) 9.3.0
    reproduce (this is a W=1 build):
            wget <a
    href="https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross">https://raw.githubusercontent.com/intel/lkp-tests/master/sbin/make.cross</a> -O ~/bin/make.cross
            chmod +x ~/bin/make.cross
            # <a
    href="https://github.com/0day-ci/linux/commit/db2ec6f1e52293817f380a4875e01c36a4195c19">https://github.com/0day-ci/linux/commit/db2ec6f1e52293817f380a4875e01c36a4195c19</a>
            git remote add linux-review <a
    href="https://github.com/0day-ci/linux">https://github.com/0day-ci/linux</a>
            git fetch --no-tags linux-review Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851
            git checkout db2ec6f1e52293817f380a4875e01c36a4195c19
            # save the attached .config to linux build tree
            COMPILER_INSTALL_PATH=$HOME/0day COMPILER=gcc-9.3.0 make.cross ARCH=powerpc 
    
    If you fix the issue, kindly add following tag as appropriate
    Reported-by: kernel test robot &lt;lkp@intel.com&gt;
    
    All warnings (new ones prefixed by &gt;&gt;):
    
       In file included from include/linux/printk.h:7,
                        from include/linux/kernel.h:17,
                        from include/asm-generic/bug.h:20,
                        from arch/powerpc/include/asm/bug.h:109,
                        from include/linux/bug.h:5,
                        from arch/powerpc/include/asm/mmu.h:147,
                        from arch/powerpc/include/asm/paca.h:18,
                        from arch/powerpc/include/asm/current.h:13,
                        from include/linux/sched.h:12,
                        from include/linux/blkdev.h:5,
                        from drivers/usb/gadget/function/f_mass_storage.c:201:
       drivers/usb/gadget/function/f_mass_storage.c: In function &#39;cdr_guess_medium_type&#39;:
    <span
    class="q">&gt;&gt; include/linux/kern_levels.h:5:18: warning: format &#39;%u&#39; expects argument of type &#39;unsigned int&#39;, but argument 4 has type &#39;size_t&#39; {aka &#39;long unsigned int&#39;} [-Wformat=]
    </span>       5 | #define KERN_SOH &#34;\001&#34;  /* ASCII Start Of Header */
             |                  ^~~~~~
       include/linux/kern_levels.h:15:20: note: in expansion of macro &#39;KERN_SOH&#39;
          15 | #define KERN_DEBUG KERN_SOH &#34;7&#34; /* debug-level messages */
             |                    ^~~~~~~~
       include/linux/printk.h:427:9: note: in expansion of macro &#39;KERN_DEBUG&#39;
         427 |  printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
             |         ^~~~~~~~~~
       drivers/usb/gadget/function/storage_common.h:24:4: note: in expansion of macro &#39;pr_debug&#39;
          24 |    func(&#34;%s/%s: &#34; fmt, *(lun)-&gt;name_pfx,  \
             |    ^~~~
       drivers/usb/gadget/function/storage_common.h:30:34: note: in expansion of macro &#39;_LMSG&#39;
          30 | #define LDBG(lun, fmt, args...)  _LMSG(pr_debug, lun, fmt, ## args)
             |                                  ^~~~~
       drivers/usb/gadget/function/f_mass_storage.c:1964:2: note: in expansion of macro &#39;LDBG&#39;
        1964 |  LDBG(curlun,
             |  ^~~~
       drivers/usb/gadget/function/f_mass_storage.c:1965:27: note: format string is defined here
        1965 |       &#34;Disc layout size (%u) exceeds all known media types, assuming BD - ROM !\n&#34;,
             |                          ~^
             |                           |
             |                           unsigned int
             |                          %lu
       In file included from include/linux/printk.h:7,
                        from include/linux/kernel.h:17,
                        from include/asm-generic/bug.h:20,
                        from arch/powerpc/include/asm/bug.h:109,
                        from include/linux/bug.h:5,
                        from arch/powerpc/include/asm/mmu.h:147,
                        from arch/powerpc/include/asm/paca.h:18,
                        from arch/powerpc/include/asm/current.h:13,
                        from include/linux/sched.h:12,
                        from include/linux/blkdev.h:5,
                        from drivers/usb/gadget/function/f_mass_storage.c:201:
       include/linux/kern_levels.h:5:18: warning: format &#39;%u&#39; expects argument of type &#39;unsigned int&#39;, but argument 3 has type &#39;size_t&#39; {aka &#39;long unsigned int&#39;} [-Wformat=]
           5 | #define KERN_SOH &#34;\001&#34;  /* ASCII Start Of Header */
             |                  ^~~~~~
       include/linux/kern_levels.h:15:20: note: in expansion of macro &#39;KERN_SOH&#39;
          15 | #define KERN_DEBUG KERN_SOH &#34;7&#34; /* debug-level messages */
             |                    ^~~~~~~~
       include/linux/printk.h:427:9: note: in expansion of macro &#39;KERN_DEBUG&#39;
         427 |  printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
             |         ^~~~~~~~~~
       drivers/usb/gadget/function/storage_common.h:27:4: note: in expansion of macro &#39;pr_debug&#39;
          27 |    func(&#34;%s: &#34; fmt, (lun)-&gt;name, ## args);  \
             |    ^~~~
       drivers/usb/gadget/function/storage_common.h:30:34: note: in expansion of macro &#39;_LMSG&#39;
          30 | #define LDBG(lun, fmt, args...)  _LMSG(pr_debug, lun, fmt, ## args)
             |                                  ^~~~~
       drivers/usb/gadget/function/f_mass_storage.c:1964:2: note: in expansion of macro &#39;LDBG&#39;
        1964 |  LDBG(curlun,
             |  ^~~~
       drivers/usb/gadget/function/f_mass_storage.c:1965:27: note: format string is defined here
        1965 |       &#34;Disc layout size (%u) exceeds all known media types, assuming BD - ROM !\n&#34;,
             |                          ~^
             |                           |
             |                           unsigned int
             |                          %lu
       drivers/usb/gadget/function/f_mass_storage.c: At top level:
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2231:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2231 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[6].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2231:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2231 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2233:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2233 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[7].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2233:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2233 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2235:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2235 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[8].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2235:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2235 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2259:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2259 |  { CDB_REG_CHECKER_BLK(VERIFY, 10, CDB_NO_SIZE_FIELD, DATA_DIR_NONE,
    --
       drivers/usb/gadget/function/f_mass_storage.c: In function &#39;invalidate_sub&#39;:
       drivers/usb/gadget/function/f_mass_storage.c:1166:16: warning: variable &#39;rc&#39; set but not used [-Wunused-but-set-variable]
        1166 |  unsigned long rc;
             |                ^~
       In file included from include/linux/kernel.h:17,
                        from include/asm-generic/bug.h:20,
                        from arch/powerpc/include/asm/bug.h:109,
                        from include/linux/bug.h:5,
                        from arch/powerpc/include/asm/mmu.h:147,
                        from arch/powerpc/include/asm/paca.h:18,
                        from arch/powerpc/include/asm/current.h:13,
                        from include/linux/sched.h:12,
                        from include/linux/blkdev.h:5,
                        from drivers/usb/gadget/function/f_mass_storage.c:201:
       drivers/usb/gadget/function/f_mass_storage.c: In function &#39;cdr_guess_medium_type&#39;:
    <span
    class="q">&gt;&gt; include/linux/kern_levels.h:5:18: warning: format &#39;%u&#39; expects argument of type &#39;unsigned int&#39;, but argument 4 has type &#39;size_t&#39; {aka &#39;long unsigned int&#39;} [-Wformat=]
    </span>       5 | #define KERN_SOH &#34;\001&#34;  /* ASCII Start Of Header */
             |                  ^~~~~~
       include/linux/printk.h:140:10: note: in definition of macro &#39;no_printk&#39;
         140 |   printk(fmt, ##__VA_ARGS__);  \
             |          ^~~
       include/linux/kern_levels.h:15:20: note: in expansion of macro &#39;KERN_SOH&#39;
          15 | #define KERN_DEBUG KERN_SOH &#34;7&#34; /* debug-level messages */
             |                    ^~~~~~~~
       include/linux/printk.h:430:12: note: in expansion of macro &#39;KERN_DEBUG&#39;
         430 |  no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
             |            ^~~~~~~~~~
       drivers/usb/gadget/function/storage_common.h:24:4: note: in expansion of macro &#39;pr_debug&#39;
          24 |    func(&#34;%s/%s: &#34; fmt, *(lun)-&gt;name_pfx,  \
             |    ^~~~
       drivers/usb/gadget/function/storage_common.h:30:34: note: in expansion of macro &#39;_LMSG&#39;
          30 | #define LDBG(lun, fmt, args...)  _LMSG(pr_debug, lun, fmt, ## args)
             |                                  ^~~~~
       drivers/usb/gadget/function/f_mass_storage.c:1964:2: note: in expansion of macro &#39;LDBG&#39;
        1964 |  LDBG(curlun,
             |  ^~~~
       drivers/usb/gadget/function/f_mass_storage.c:1965:27: note: format string is defined here
        1965 |       &#34;Disc layout size (%u) exceeds all known media types, assuming BD - ROM !\n&#34;,
             |                          ~^
             |                           |
             |                           unsigned int
             |                          %lu
       In file included from include/linux/kernel.h:17,
                        from include/asm-generic/bug.h:20,
                        from arch/powerpc/include/asm/bug.h:109,
                        from include/linux/bug.h:5,
                        from arch/powerpc/include/asm/mmu.h:147,
                        from arch/powerpc/include/asm/paca.h:18,
                        from arch/powerpc/include/asm/current.h:13,
                        from include/linux/sched.h:12,
                        from include/linux/blkdev.h:5,
                        from drivers/usb/gadget/function/f_mass_storage.c:201:
       include/linux/kern_levels.h:5:18: warning: format &#39;%u&#39; expects argument of type &#39;unsigned int&#39;, but argument 3 has type &#39;size_t&#39; {aka &#39;long unsigned int&#39;} [-Wformat=]
           5 | #define KERN_SOH &#34;\001&#34;  /* ASCII Start Of Header */
             |                  ^~~~~~
       include/linux/printk.h:140:10: note: in definition of macro &#39;no_printk&#39;
         140 |   printk(fmt, ##__VA_ARGS__);  \
             |          ^~~
       include/linux/kern_levels.h:15:20: note: in expansion of macro &#39;KERN_SOH&#39;
          15 | #define KERN_DEBUG KERN_SOH &#34;7&#34; /* debug-level messages */
             |                    ^~~~~~~~
       include/linux/printk.h:430:12: note: in expansion of macro &#39;KERN_DEBUG&#39;
         430 |  no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
             |            ^~~~~~~~~~
       drivers/usb/gadget/function/storage_common.h:27:4: note: in expansion of macro &#39;pr_debug&#39;
          27 |    func(&#34;%s: &#34; fmt, (lun)-&gt;name, ## args);  \
             |    ^~~~
       drivers/usb/gadget/function/storage_common.h:30:34: note: in expansion of macro &#39;_LMSG&#39;
          30 | #define LDBG(lun, fmt, args...)  _LMSG(pr_debug, lun, fmt, ## args)
             |                                  ^~~~~
       drivers/usb/gadget/function/f_mass_storage.c:1964:2: note: in expansion of macro &#39;LDBG&#39;
        1964 |  LDBG(curlun,
             |  ^~~~
       drivers/usb/gadget/function/f_mass_storage.c:1965:27: note: format string is defined here
        1965 |       &#34;Disc layout size (%u) exceeds all known media types, assuming BD - ROM !\n&#34;,
             |                          ~^
             |                           |
             |                           unsigned int
             |                          %lu
       drivers/usb/gadget/function/f_mass_storage.c: At top level:
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2231:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2231 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[6].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2231:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2231 |  { CDB_REG_CHECKER_BLK(READ_6, 6, CDB_SIZE_FIELD_4, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2233:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2233 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[7].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2233:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2233 |  { CDB_REG_CHECKER_BLK(READ_10, 10, CDB_SIZE_FIELD_7, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: warning: initialized field overwritten [-Woverride-init]
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2235:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2235 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
       drivers/usb/gadget/function/f_mass_storage.c:311:23: note: (near initialization for &#39;cdb_checker_table[8].do_check_command&#39;)
         311 |   .do_check_command = &#38;check_command_size_in_blocks
             |                       ^
       drivers/usb/gadget/function/f_mass_storage.c:2235:4: note: in expansion of macro &#39;CDB_REG_CHECKER_BLK&#39;
        2235 |  { CDB_REG_CHECKER_BLK(READ_12, 12, CDB_SIZE_FIELD_6, DATA_DIR_TO_HOST,
             |    ^~~~~~~~~~~~~~~~~~~
    
    
    vim +5 include/linux/kern_levels.h
    
    314ba3520e513a Joe Perches 2012-07-30  4  
    04d2c8c83d0e3a Joe Perches 2012-07-30 @5  #define KERN_SOH	&#34;\001&#34;		/* ASCII Start Of Header */
    04d2c8c83d0e3a Joe Perches 2012-07-30  6  #define KERN_SOH_ASCII	&#39;\001&#39;
    04d2c8c83d0e3a Joe Perches 2012-07-30  7  
    
    ---
    0-DAY CI Kernel Test Service, Intel Corporation
    <a
    href="https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org">https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org</a>
    
    <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/2-a.bin">[-- Attachment #2: .config.gz --]
    [-- Type: application/gzip, Size: 44957 bytes --]</a>
    
    <a
    href=#m31ec12223279c2669d001a846804b3ce28dda048
    id=e31ec12223279c2669d001a846804b3ce28dda048>^</a> <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/">permalink</a> <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/raw">raw</a> <a
    href="../../202106270815.ikppB5sB-lkp@intel.com/#R">reply</a>	[<a
    href="../../202106270815.ikppB5sB-lkp@intel.com/T/#u"><b>flat</b></a>|<a
    href="../../202106270815.ikppB5sB-lkp@intel.com/t/#u">nested</a>] <a
    href=#r31ec12223279c2669d001a846804b3ce28dda048>16+ messages in thread</a></pre><hr><pre><a
    href=#ed17f3ece942d5fa5c6d04d837a76c9938262a044
    id=md17f3ece942d5fa5c6d04d837a76c9938262a044>*</a> <b>Re: [PATCH 5/6] FMS: Add the SCSI Get Configuration command.</b>
      2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d">[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
      2021-06-27  0:44   ` <a
    href="#m31ec12223279c2669d001a846804b3ce28dda048">kernel test robot</a>
    <b>@ 2021-06-27  4:42   ` kernel test robot</b>
      2021-06-28  9:53   ` <a
    href="#mf92cecbdbd7f078aafb77c93f35e3f89b1b3525f">Christoph Hellwig</a>
      <a
    href=#rd17f3ece942d5fa5c6d04d837a76c9938262a044>2 siblings, 0 replies; 16+ messages in thread</a>
    From: kernel test robot @ 2021-06-27  4:42 UTC (<a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/">permalink</a> / <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/raw">raw</a>)
      To: Igor Kononenko, Jens Axboe, Felipe Balbi, Greg Kroah-Hartman,
        James E.J. Bottomley, Martin K. Petersen
      Cc: kbuild-all, openbmc, Igor Kononenko, <a
    href="../../../linux-ide/?t=20210627044339">linux-ide</a>, <a
    href="../../../lkml/?t=20210627044339">linux-kernel</a>,
        <a
    href="../../../linux-usb/?t=20210627044339">linux-usb</a>
    
    <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 9125 bytes --]</a>
    
    Hi Igor,
    
    Thank you for the patch! Perhaps something to improve:
    
    [auto build test WARNING on mkp-scsi/for-next]
    [also build test WARNING on scsi/for-next linus/master balbi-usb/testing/next v5.13-rc7 next-20210625]
    [If your patch is applied to the wrong git tree, kindly drop us a note.
    And when submitting patch, we suggest to use &#39;--base&#39; as documented in
    <a
    href="https://git-scm.com/docs/git-format-patch">https://git-scm.com/docs/git-format-patch</a>]
    
    url:    <a
    href="https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851">https://github.com/0day-ci/linux/commits/Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851</a>
    base:   <a
    href="https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git">https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git</a> for-next
    config: i386-randconfig-s002-20210627 (attached as .config)
    compiler: gcc-9 (Debian 9.3.0-22) 9.3.0
    reproduce:
            # apt-get install sparse
            # sparse version: v0.6.3-341-g8af24329-dirty
            # <a
    href="https://github.com/0day-ci/linux/commit/db2ec6f1e52293817f380a4875e01c36a4195c19">https://github.com/0day-ci/linux/commit/db2ec6f1e52293817f380a4875e01c36a4195c19</a>
            git remote add linux-review <a
    href="https://github.com/0day-ci/linux">https://github.com/0day-ci/linux</a>
            git fetch --no-tags linux-review Igor-Kononenko/usb-gadget-mass-storage-Improve-the-signature-of-SCSI-handler-function/20210627-061851
            git checkout db2ec6f1e52293817f380a4875e01c36a4195c19
            # save the attached .config to linux build tree
            make W=1 C=1 CF=&#39;-fdiagnostic-prefix -D__CHECK_ENDIAN__&#39; O=build_dir ARCH=i386 SHELL=/bin/bash drivers/usb/gadget/function/
    
    If you fix the issue, kindly add following tag as appropriate
    Reported-by: kernel test robot &lt;lkp@intel.com&gt;
    
    
    sparse warnings: (new ones prefixed by &gt;&gt;)
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:1988:57: sparse: sparse: restricted __be16 degrades to integer
    &gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:2060:30: sparse: sparse: incorrect type in assignment (different base types) @@     expected unsigned int [usertype] data_len @@     got restricted __be32 [usertype] @@
    </span>   drivers/usb/gadget/function/f_mass_storage.c:2060:30: sparse:     expected unsigned int [usertype] data_len
       drivers/usb/gadget/function/f_mass_storage.c:2060:30: sparse:     got restricted __be32 [usertype]
    <span
    class="q">&gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:2062:17: sparse: sparse: cast from restricted __be16
    &gt;&gt; drivers/usb/gadget/function/f_mass_storage.c:2061:34: sparse: sparse: incorrect type in assignment (different base types) @@     expected unsigned short [usertype] curr_profile @@     got restricted __be16 [usertype] @@
    </span>   drivers/usb/gadget/function/f_mass_storage.c:2061:34: sparse:     expected unsigned short [usertype] curr_profile
       drivers/usb/gadget/function/f_mass_storage.c:2061:34: sparse:     got restricted __be16 [usertype]
       drivers/usb/gadget/function/f_mass_storage.c:2231:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2231:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2233:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2233:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2235:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2235:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2259:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2259:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2261:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2261:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2263:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2263:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c:2265:11: sparse: sparse: Initializer entry defined twice
       drivers/usb/gadget/function/f_mass_storage.c:2265:11: sparse:   also defined here
       drivers/usb/gadget/function/f_mass_storage.c: note: in included file (through include/linux/rcuwait.h, include/linux/percpu-rwsem.h, include/linux/fs.h, ...):
       include/linux/sched/signal.h:285:28: sparse: sparse: incorrect type in argument 1 (different address spaces) @@     expected struct spinlock [usertype] *lock @@     got struct spinlock [noderef] __rcu * @@
       include/linux/sched/signal.h:285:28: sparse:     expected struct spinlock [usertype] *lock
       include/linux/sched/signal.h:285:28: sparse:     got struct spinlock [noderef] __rcu *
       include/linux/sched/signal.h:287:30: sparse: sparse: incorrect type in argument 1 (different address spaces) @@     expected struct spinlock [usertype] *lock @@     got struct spinlock [noderef] __rcu * @@
       include/linux/sched/signal.h:287:30: sparse:     expected struct spinlock [usertype] *lock
       include/linux/sched/signal.h:287:30: sparse:     got struct spinlock [noderef] __rcu *
    
    vim +1988 drivers/usb/gadget/function/f_mass_storage.c
    
      1969	
      1970	/* Adjust current profile which depended on an inserted medium */
      1971	static inline void cdf_populate_profile_list(struct fsg_common *common,
      1972						     struct cdr_features **feature)
      1973	{
      1974		__be16 current_media_type = cdr_guess_medium_type(common);
      1975		struct mmc_profile *profiles =
      1976			(*feature)-&gt;feature.profile_list.profiles;
      1977		int i;
      1978	
      1979		/* copy profile list to the response buffer */
      1980		memcpy(profiles, cdf_supported_profiles,
      1981		       sizeof(cdf_supported_profiles));
      1982		for (i = 0; i &lt; CDF_PROFILES_COUNT; ++i) {
      1983			/*
      1984			 * Reset the current profile bit,
      1985			 * because it might be set from the previous one
      1986			 */
      1987			profiles[i].current_p = 0;
    <span
    class="q">&gt; 1988			if (be16_to_cpu(profiles[i].profile) == current_media_type) {
    </span>  1989				DBG(common, &#34;Fill current profile: curr=(%04Xh)\n&#34;,
      1990				    be16_to_cpu(profiles[i].profile));
      1991				profiles[i].current_p = 1;
      1992			}
      1993		}
      1994	}
      1995	
      1996	static int do_get_configuration(struct fsg_common *common,
      1997					struct fsg_buffhd *bh)
      1998	{
      1999		struct fsg_lun *curlun = common-&gt;curlun;
      2000		int i;
      2001		struct cdb_get_configuration *cdb =
      2002			(struct cdb_get_configuration *)common-&gt;cmnd;
      2003		size_t buffer_size = sizeof(struct feature_header);
      2004		size_t generic_desc_size = sizeof(struct cdb_ft_generic);
      2005		struct feature_header *ret_header = (struct feature_header *)bh-&gt;buf;
      2006		u8 *ret_data = ((u8 *)ret_header) + buffer_size;
      2007	
      2008		LDBG(curlun, &#34;Requesting features from 0x%04X, with RT flag 0x%02X\n&#34;,
      2009		     be16_to_cpu(cdb-&gt;sfn), cdb-&gt;rt);
      2010	
      2011		if (!common-&gt;curlun || !common-&gt;curlun-&gt;cdrom)
      2012			return -EINVAL;
      2013	
      2014		/* Go over *all* features, and copy them according to RT value */
      2015		for (i = 0; i &lt; ARRAY_SIZE(features_table); ++i) {
      2016			struct cdb_ft_generic *generic =
      2017				(struct cdb_ft_generic *)&#38;features_table[i];
      2018			struct cdr_features *feature = &#38;features_table[i];
      2019	
      2020			if (feature-&gt;populate != NULL)
      2021				feature-&gt;populate(common, &#38;feature);
      2022	
      2023			// a) RT is 0x00 and feature&#39;s code &gt;= SFN
      2024			// b) RT is 0x01, feature&#39;s code &gt;= SFN and feature has &#39;current&#39; bit set
      2025			// c) RT is 0x02 and feature&#39;s code == SFN
      2026	
      2027			if (be16_to_cpu(generic-&gt;code) &gt;= be16_to_cpu(cdb-&gt;sfn)) {
      2028				if ((cdb-&gt;rt == CDR_CFG_RT_FULL) ||
      2029				    (cdb-&gt;rt == CDR_CFG_RT_CURRENT &#38;&#38;
      2030				     generic-&gt;vpc.cur) ||
      2031				    (cdb-&gt;rt == CDR_CFG_RT_SPECIFIED_SFN &#38;&#38;
      2032				     be16_to_cpu(generic-&gt;code) ==
      2033					     be16_to_cpu(cdb-&gt;sfn))) {
      2034					LDBG(curlun, &#34;Copying feature 0x%04X\n&#34;,
      2035					     be16_to_cpu(generic-&gt;code));
      2036	
      2037					memset(ret_data, 0,
      2038					       (generic-&gt;length + generic_desc_size));
      2039					/* Copy feature */
      2040					memcpy(ret_data, feature,
      2041					       (generic-&gt;length + generic_desc_size));
      2042					buffer_size +=
      2043						(generic-&gt;length + generic_desc_size);
      2044					ret_data +=
      2045						(generic-&gt;length + generic_desc_size);
      2046	
      2047					/* Break the loop if RT is CDR_CFG_RT_SPECIFIED_SFN */
      2048					if (cdb-&gt;rt == CDR_CFG_RT_SPECIFIED_SFN) {
      2049						LDBG(curlun,
      2050						     &#34;Got the feature we wanted (0x%04X), breaking the loop\n&#34;,
      2051						     be16_to_cpu(cdb-&gt;sfn));
      2052						break;
      2053					}
      2054				}
      2055			}
      2056		}
      2057	
      2058		memset(ret_header, 0, sizeof(struct feature_header));
      2059		/* Header */
    <span
    class="q">&gt; 2060		ret_header-&gt;data_len = cpu_to_be32(buffer_size - generic_desc_size);
    &gt; 2061		ret_header-&gt;curr_profile =
    &gt; 2062			cpu_to_be16(cdr_guess_medium_type(common));
    </span>  2063	
      2064		dump_msg(common, &#34;feature header&#34;, (u8 *)ret_header,
      2065			 sizeof(struct feature_header));
      2066	
      2067		dump_msg(common, &#34;features table&#34;, (u8 *)bh-&gt;buf, buffer_size);
      2068	
      2069		common-&gt;data_size_to_handle = buffer_size;
      2070		return 0;
      2071	}
      2072	
    
    ---
    0-DAY CI Kernel Test Service, Intel Corporation
    <a
    href="https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org">https://lists.01.org/hyperkitty/list/kbuild-all@lists.01.org</a>
    
    <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/2-a.bin">[-- Attachment #2: .config.gz --]
    [-- Type: application/gzip, Size: 47122 bytes --]</a>
    
    <a
    href=#md17f3ece942d5fa5c6d04d837a76c9938262a044
    id=ed17f3ece942d5fa5c6d04d837a76c9938262a044>^</a> <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/">permalink</a> <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/raw">raw</a> <a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/#R">reply</a>	[<a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/T/#u"><b>flat</b></a>|<a
    href="../../202106271216.SEjCCKSb-lkp@intel.com/t/#u">nested</a>] <a
    href=#rd17f3ece942d5fa5c6d04d837a76c9938262a044>16+ messages in thread</a></pre><hr><pre><a
    href=#edf9a72eef529aca328a560f9bb4d1ed0af2f5445
    id=mdf9a72eef529aca328a560f9bb4d1ed0af2f5445>*</a> <b>Re: [PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</b>
      2021-06-26 21:18 ` <a
    href="#ma15d1b956bb4d021019ecfe176f738e38de1c946">[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</a> Igor Kononenko
    <b>@ 2021-06-27 14:18   ` Alan Stern</b>
           [not found]     ` &lt;<a
    href=#r83eeba2a1d348b1b8789a1a1c30e0e4ac1bb1306>ded6e647-6dd9-ebd0-0ea5-b20e113bf57f@yadro.com</a>&gt;
      <a
    href=#rdf9a72eef529aca328a560f9bb4d1ed0af2f5445>0 siblings, 1 reply; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-27 14:18 UTC (<a
    href="../../20210627141836.GC624763@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210627141836.GC624763@rowland.harvard.edu/raw">raw</a>)
      To: Igor Kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, openbmc, <a
    href="../../../linux-usb/?t=20210627141840">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210627141840">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 12:18:14AM +0300, Igor Kononenko wrote:
    <span
    class="q">&gt; SCSI command handlers currently have an ambiguous return value. This
    </span>
    (I dislike very much this way of writing patch descriptions.  Unless
    the reader has already looked at the email subject line and remembers
    that this patch affects the mass-storage gadget, he will think the
    sentence above is talking about command handlers in the SCSI core -- a
    completely different part of the kernel.  When writing patch
    descriptions, please do not assume that the reader already knows what
    the patch is about.)
    
    <span
    class="q">&gt; return value may indicate the length of the data written to the response
    &gt; buffer and the command&#39;s processing status. Thus, the understanding of
    &gt; command handling may be implicit.
    </span>
    The return value is _not_ ambiguous.  If the value is &gt;= 0 then it is
    a data length, otherwise it is a status.  Yes, this is implicit, but it
    is a very common pattern used throughout the kernel and everyone
    understands it.
    
    <span
    class="q">&gt; After this patch, the output buffer&#39;s size will be set in the
    &gt; &#39;data_size_to_handle&#39; field of &#39;struct fsg_common&#39;, and the command
    &gt; handler&#39;s return value indicates only the processing status.
    </span>
    What is the reason for making this change?  Does it fix any problems
    or prepare the way for any future patches?  It seems like this is
    completely unnecessary.
    
    Alan Stern
    
    <span
    class="q">&gt; Tested: By probing the USBGadget Mass-Storage on the YADRO VEGMAN
    &gt; BMC(AST2500) sample, each SCSI command was sent through HOST-&gt;BMC; the
    &gt; USBGadget MassStorage debug print showed all sent commands works
    &gt; properly.
    &gt; 
    &gt; Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    </span>
    <a
    href=#mdf9a72eef529aca328a560f9bb4d1ed0af2f5445
    id=edf9a72eef529aca328a560f9bb4d1ed0af2f5445>^</a> <a
    href="../../20210627141836.GC624763@rowland.harvard.edu/">permalink</a> <a
    href="../../20210627141836.GC624763@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210627141836.GC624763@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210627141836.GC624763@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210627141836.GC624763@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#rdf9a72eef529aca328a560f9bb4d1ed0af2f5445>16+ messages in thread</a></pre><hr><pre><a
    href=#e4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6
    id=m4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6>*</a> <b>Re: [PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</b>
      2021-06-26 21:18 ` <a
    href="#ma4dcc8b46e33a8365a8dca614cab4b78501d241c">[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</a> Igor Kononenko
      2021-06-26 23:29   ` <a
    href="#maaed19c5d26b1f62307d2d9d1215506946eab6bb">kernel test robot</a>
    <b>@ 2021-06-27 14:23   ` Alan Stern</b>
           [not found]     ` &lt;<a
    href=#rf74b6d8e32965105d0fbbe7249d36d7839ae8d67>bc8059b1-0f56-fc3b-6ec8-0bf1043fc9e5@yadro.com</a>&gt;
      <a
    href=#r4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6>1 sibling, 1 reply; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-27 14:23 UTC (<a
    href="../../20210627142355.GD624763@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210627142355.GD624763@rowland.harvard.edu/raw">raw</a>)
      To: Igor Kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, openbmc, <a
    href="../../../linux-usb/?t=20210627142358">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210627142358">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 12:18:15AM +0300, Igor Kononenko wrote:
    <span
    class="q">&gt; Implements a universal way to define SCSI commands and configure
    &gt; precheck handlers.
    </span>
    What is the reason for doing this?
    
    At first glance, it appears you have added a great deal of complexity
    to the driver.  The patch replaces a large amount of easily understood
    (albeit rather repetitious) code with an approximately equal amount
    of rather complicated code.  This does not seem like an improvement.
    
    Furthermore, the code you removed is flexible; it easily allows for
    small variations as neede by some command handlers.  But the code you
    added is all table-driven, which does not easily permit arbitrary
    variations.
    
    <span
    class="q">&gt; Tested: By probing the USBGadget Mass-Storage on the YADRO VEGMAN
    &gt; BMC(AST2500) sample, each SCSI command was sent through HOST-&gt;BMC; the
    &gt; USBGadget MassStorage debug print showed all sent commands works
    &gt; properly.
    &gt; 
    &gt; Signed-off-by: Igor Kononenko &lt;i.kononenko@yadro.com&gt;
    &gt; ---
    &gt;  drivers/usb/gadget/function/f_mass_storage.c | 540 +++++++++++--------
    &gt;  drivers/usb/gadget/function/storage_common.h |   5 +
    &gt;  2 files changed, 310 insertions(+), 235 deletions(-)
    </span>
    I don&#39;t see the point of adding 75 lines to the kernel source if they
    don&#39;t accomplish anything new.
    
    Alan Stern
    
    <a
    href=#m4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6
    id=e4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6>^</a> <a
    href="../../20210627142355.GD624763@rowland.harvard.edu/">permalink</a> <a
    href="../../20210627142355.GD624763@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210627142355.GD624763@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210627142355.GD624763@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210627142355.GD624763@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#r4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6>16+ messages in thread</a></pre><hr><pre><a
    href=#e35fd048e76c49d9594d614700b86a72f47f5ee9f
    id=m35fd048e76c49d9594d614700b86a72f47f5ee9f>*</a> <b>Re: [PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</b>
      2021-06-26 21:18 ` <a
    href="#m992ff2558771731a4569b5f8b060a9e264f524d1">[PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</a> Igor Kononenko
    <b>@ 2021-06-27 14:29   ` Alan Stern</b>
           [not found]     ` &lt;<a
    href=#r683401630a462c7816db0bd6c4dbd099bf9e5e17>3f9c6e4a-18b7-db11-8b23-f0473a649d06@yadro.com</a>&gt;
      <a
    href=#r35fd048e76c49d9594d614700b86a72f47f5ee9f>0 siblings, 1 reply; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-27 14:29 UTC (<a
    href="../../20210627142952.GE624763@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210627142952.GE624763@rowland.harvard.edu/raw">raw</a>)
      To: Igor Kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, Jens Axboe, openbmc, <a
    href="../../../linux-usb/?t=20210627142955">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210627142955">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 12:18:16AM +0300, Igor Kononenko wrote:
    <span
    class="q">&gt; The DVD-ROM required the SCSI 6.25 READ TOC/PMA/ATIP Command formats:
    &gt;  * Response Format 0000b: Formatted TOC
    &gt;  * Response Format 0001b: Multi-session Information
    &gt; (MMC-6 Specification).
    &gt; 
    &gt; This patch adds an implementation of that described above formats.
    </span>
    I will sum up the last four patches of this series by saying that they
    add features for emulating DVD-ROM and BD devices.  Doing so increases
    the size of the f_mass_storage driver by a considerable amount and
    also adds a large amount of new material to Jens Axboe&#39;s
    include/uapi/linux/cdrom.h.
    
    Is any of this really needed?  What usage scenarios require
    f_mass_storage to emulate a DVD-ROM that couldn&#39;t use f_tcm instead?
    
    Alan Stern
    
    <a
    href=#m35fd048e76c49d9594d614700b86a72f47f5ee9f
    id=e35fd048e76c49d9594d614700b86a72f47f5ee9f>^</a> <a
    href="../../20210627142952.GE624763@rowland.harvard.edu/">permalink</a> <a
    href="../../20210627142952.GE624763@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210627142952.GE624763@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210627142952.GE624763@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210627142952.GE624763@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#r35fd048e76c49d9594d614700b86a72f47f5ee9f>16+ messages in thread</a></pre><hr><pre><a
    href=#e2ae63575e3b9fca8021a07688446713c75ed0660
    id=m2ae63575e3b9fca8021a07688446713c75ed0660>*</a> <b>Re: [PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</b>
           [not found]     ` &lt;<a
    href=#r83eeba2a1d348b1b8789a1a1c30e0e4ac1bb1306>ded6e647-6dd9-ebd0-0ea5-b20e113bf57f@yadro.com</a>&gt;
    <b>@ 2021-06-27 16:39       ` Alan Stern</b>
      <a
    href=#r2ae63575e3b9fca8021a07688446713c75ed0660>0 siblings, 0 replies; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-27 16:39 UTC (<a
    href="../../20210627163933.GA628603@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210627163933.GA628603@rowland.harvard.edu/raw">raw</a>)
      To: i.kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, openbmc, <a
    href="../../../linux-usb/?t=20210627163936">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210627163936">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 06:32:03PM +0300, i.kononenko wrote:
    <span
    class="q">&gt; Good morning, Alan!
    &gt; 
    &gt; First of all, thank you for your time to review my first patchset for 
    &gt; the Linux Kernel and valuable advice on the right way of patchwriting!
    &gt; 
    &gt; On 27.06.2021 17:18, Alan Stern wrote:
    &gt; &gt; On Sun, Jun 27, 2021 at 12:18:14AM +0300, Igor Kononenko wrote:
    &gt; &gt;&gt; SCSI command handlers currently have an ambiguous return value. This
    &gt; &gt; 
    &gt; &gt; (I dislike very much this way of writing patch descriptions.  Unless
    &gt; &gt; the reader has already looked at the email subject line and remembers
    &gt; &gt; that this patch affects the mass-storage gadget, he will think the
    &gt; &gt; sentence above is talking about command handlers in the SCSI core -- a
    &gt; &gt; completely different part of the kernel.  When writing patch
    &gt; &gt; descriptions, please do not assume that the reader already knows what
    &gt; &gt; the patch is about.)
    &gt; &gt; 
    &gt; &gt;&gt; return value may indicate the length of the data written to the response
    &gt; &gt;&gt; buffer and the command&#39;s processing status. Thus, the understanding of
    &gt; &gt;&gt; command handling may be implicit.
    &gt; 
    &gt; First of all, thank you for your time to review my first patchset for the
    &gt; Linux Kernel and valuable advice on the right way of patchwriting!
    &gt; 
    &gt; I noticed that the status/datasize return value pattern is pervasive for 
    &gt; Linux and used through many subsystems. But for the f_mass_storage.c,
    &gt; such approach use case is not documented anywhere, and implementation has 
    &gt; too many magic-constant, e.g.
    &gt; ```
    &gt; static int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)
    &gt; {
    &gt;    ....
    &gt;    return 36;
    &gt; }
    &gt; ```
    &gt; IMHO, this way is not giving the developer an explicit understanding of 
    &gt; &#39;what is the 36&#39; and its origin.
    &gt; If moving to the suggested way is unwanted, I&#39;d keep the implementation 
    &gt; as is with additional documentation for each function where uses this 
    &gt; approach.
    </span>
    Since every one of the command handler functions uses this convention, 
    it would be wasteful to have separate documentation of the return value 
    for each function.  A single documentation comment that covers all the 
    command handlers would be acceptable.
    
    <span
    class="q">&gt; Additionally, I guess, define clarify macros of return value instead of 
    &gt; magic numbers is required.
    </span>
    If you want, okay.  That should go in a separate patch from the 
    documentation patch.
    
    Also, since the return values are different for each command handler, I 
    suggest that the macro definitions be placed along with the handler 
    functions and not in a separate header file.  Having a separate file for 
    these macros would not make any sense, because the values do not need to 
    be shared across multiple functions or source files.
    
    <span
    class="q">&gt; &gt; The return value is _not_ ambiguous.  If the value is &gt;= 0 then it is
    &gt; &gt; a data length, otherwise it is a status.  Yes, this is implicit, but it
    &gt; &gt; is a very common pattern used throughout the kernel and everyone
    &gt; &gt; understands it.
    &gt; &gt; 
    &gt; &gt;&gt; After this patch, the output buffer&#39;s size will be set in the
    &gt; &gt;&gt; &#39;data_size_to_handle&#39; field of &#39;struct fsg_common&#39;, and the command
    &gt; &gt;&gt; handler&#39;s return value indicates only the processing status.
    &gt; &gt; 
    &gt; &gt; What is the reason for making this change?  Does it fix any problems
    &gt; &gt; or prepare the way for any future patches?  It seems like this is
    &gt; &gt; completely unnecessary.
    &gt; 
    &gt; Yes, the patch uses as part of the incoming implementation of refactoring
    &gt; &#39;usb:gadget:mass-storage:scsi&#39; command handling.
    </span>
    That incoming implementation uses the refactored command handling but 
    doesn&#39;t depend on the refactoring.  It could just as easily use the 
    existing command handling.
    
    <span
    class="q">&gt; I believed the suggested improvement would be useful for the community as 
    &gt; an improvement of code.
    </span>
    Unless you can provide a convincing reason for this change, it doesn&#39;t 
    seem like an improvement to me.  It&#39;s no easier to read or understand, 
    and it doesn&#39;t improve execution speed on a critical pathway.  It just 
    seems like pointless code churn.
    
    Alan Stern
    
    <a
    href=#m2ae63575e3b9fca8021a07688446713c75ed0660
    id=e2ae63575e3b9fca8021a07688446713c75ed0660>^</a> <a
    href="../../20210627163933.GA628603@rowland.harvard.edu/">permalink</a> <a
    href="../../20210627163933.GA628603@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210627163933.GA628603@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210627163933.GA628603@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210627163933.GA628603@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#r2ae63575e3b9fca8021a07688446713c75ed0660>16+ messages in thread</a></pre><hr><pre><a
    href=#ecce16221ad9624292ca75bc6c86a0cc8338f1c04
    id=mcce16221ad9624292ca75bc6c86a0cc8338f1c04>*</a> <b>Re: [PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</b>
           [not found]     ` &lt;<a
    href=#rf74b6d8e32965105d0fbbe7249d36d7839ae8d67>bc8059b1-0f56-fc3b-6ec8-0bf1043fc9e5@yadro.com</a>&gt;
    <b>@ 2021-06-28  1:06       ` Alan Stern</b>
      <a
    href=#rcce16221ad9624292ca75bc6c86a0cc8338f1c04>0 siblings, 0 replies; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-28  1:06 UTC (<a
    href="../../20210628010641.GB638648@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210628010641.GB638648@rowland.harvard.edu/raw">raw</a>)
      To: i.kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, openbmc, <a
    href="../../../linux-usb/?t=20210628010644">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210628010644">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 08:14:48PM +0300, i.kononenko wrote:
    <span
    class="q">&gt; 
    &gt; 
    &gt; On 27.06.2021 17:23, Alan Stern wrote:
    &gt; &gt; On Sun, Jun 27, 2021 at 12:18:15AM +0300, Igor Kononenko wrote:
    &gt; &gt;&gt; Implements a universal way to define SCSI commands and configure
    &gt; &gt;&gt; precheck handlers.
    &gt; &gt; 
    &gt; &gt; What is the reason for doing this?
    &gt; 
    &gt; I have started implementing a way to specify a backend-file of 
    &gt; mass-storage images greater than 2.1Gb for cdrom-like mediums. 
    &gt; I notice the implementation of each scsi-command handler uses too 
    &gt; many magic-constant, hardcoded indexes and shifts. I decided to 
    &gt; define structures that contained appropriate SCSI-defined fields 
    &gt; and constant-values to clarify the code.
    &gt; 
    &gt; Additionally, I noticed, many kernel subsystems use the &#39;separate
    &gt; data and logic&#39; approach, making a code more explicit and readable.
    &gt; This looks reasonable to me, and a code looks more clearly, at 
    &gt; least - we don&#39;t need to examine each magic constant and its purpose. 
    &gt; 
    &gt; &gt; 
    &gt; &gt; At first glance, it appears you have added a great deal of complexity
    &gt; &gt; to the driver.  The patch replaces a large amount of easily understood
    &gt; &gt; (albeit rather repetitious) code with an approximately equal amount
    &gt; &gt; of rather complicated code.  This does not seem like an improvement.
    &gt; 
    &gt; The SCSI-commands table is defined as unifying a way to specify the 
    &gt; SCSI-command handler, with corresponding required data instead pass 
    &gt; it to each repeatedly switch-case block, which makes code more readable
    &gt; to me. If there isn&#39;t, I can keep the definition of SCSI-handlers as is,
    &gt; but the SCSI-data structures with their constant-values are still 
    &gt; required, in my opinion.
    &gt; 
    &gt; &gt; 
    &gt; &gt; Furthermore, the code you removed is flexible; it easily allows for
    &gt; &gt; small variations as neede by some command handlers.  But the code you
    &gt; &gt; added is all table-driven, which does not easily permit arbitrary
    &gt; &gt; variations.
    &gt; &gt; 
    &gt; 
    &gt; I don&#39;t think that the SCSI-command handlers table is an obstacle to 
    &gt; define variation into a specific handler because the current patch has 
    &gt; helper macros, which can specify a behavior for each requirement of 
    &gt; handler.
    &gt; 
    &gt; Anyway, the definition of the scsi-command handlers table may be discarded,
    &gt; because this work done to helping developers who will work the 
    &gt; &#39;usb:gadget:mass-storage&#39; subsystem in the future.
    </span>
    Can you submit a patch that adds only the data structures without the
    commands table?
    
    Alan Stern
    
    <a
    href=#mcce16221ad9624292ca75bc6c86a0cc8338f1c04
    id=ecce16221ad9624292ca75bc6c86a0cc8338f1c04>^</a> <a
    href="../../20210628010641.GB638648@rowland.harvard.edu/">permalink</a> <a
    href="../../20210628010641.GB638648@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210628010641.GB638648@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210628010641.GB638648@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210628010641.GB638648@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#rcce16221ad9624292ca75bc6c86a0cc8338f1c04>16+ messages in thread</a></pre><hr><pre><a
    href=#ef92cecbdbd7f078aafb77c93f35e3f89b1b3525f
    id=mf92cecbdbd7f078aafb77c93f35e3f89b1b3525f>*</a> <b>Re: [PATCH 5/6] FMS: Add the SCSI Get Configuration command.</b>
      2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d">[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
      2021-06-27  0:44   ` <a
    href="#m31ec12223279c2669d001a846804b3ce28dda048">kernel test robot</a>
      2021-06-27  4:42   ` <a
    href="#md17f3ece942d5fa5c6d04d837a76c9938262a044">kernel test robot</a>
    <b>@ 2021-06-28  9:53   ` Christoph Hellwig</b>
      <a
    href=#rf92cecbdbd7f078aafb77c93f35e3f89b1b3525f>2 siblings, 0 replies; 16+ messages in thread</a>
    From: Christoph Hellwig @ 2021-06-28  9:53 UTC (<a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/">permalink</a> / <a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/raw">raw</a>)
      To: Igor Kononenko
      Cc: Jens Axboe, Felipe Balbi, Greg Kroah-Hartman,
        James E.J. Bottomley, Martin K. Petersen, openbmc, <a
    href="../../../linux-ide/?t=20210628095737">linux-ide</a>,
        <a
    href="../../../lkml/?t=20210628095737">linux-kernel</a>, <a
    href="../../../linux-usb/?t=20210628095737">linux-usb</a>, <a
    href="../../../linux-scsi/?t=20210628095737">linux-scsi</a>
    
    What is FMS?  And why do only patches 5 and 6 show up on the list?
    And why does this mix changes to the SCSI layer, libata, usb-gadget and
    the CDROM UAPI in a single patch?
    
    <a
    href=#mf92cecbdbd7f078aafb77c93f35e3f89b1b3525f
    id=ef92cecbdbd7f078aafb77c93f35e3f89b1b3525f>^</a> <a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/">permalink</a> <a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/raw">raw</a> <a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/#R">reply</a>	[<a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/T/#u"><b>flat</b></a>|<a
    href="../../YNmcNvqvTFNCrMl9@infradead.org/t/#u">nested</a>] <a
    href=#rf92cecbdbd7f078aafb77c93f35e3f89b1b3525f>16+ messages in thread</a></pre><hr><pre><a
    href=#e5fb44d50215ffc5e9b25e79ba275862d87c6d9e5
    id=m5fb44d50215ffc5e9b25e79ba275862d87c6d9e5>*</a> <b>Re: [PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</b>
           [not found]     ` &lt;<a
    href=#r683401630a462c7816db0bd6c4dbd099bf9e5e17>3f9c6e4a-18b7-db11-8b23-f0473a649d06@yadro.com</a>&gt;
    <b>@ 2021-06-28 14:31       ` Alan Stern</b>
      <a
    href=#r5fb44d50215ffc5e9b25e79ba275862d87c6d9e5>0 siblings, 0 replies; 16+ messages in thread</a>
    From: Alan Stern @ 2021-06-28 14:31 UTC (<a
    href="../../20210628143158.GD656159@rowland.harvard.edu/">permalink</a> / <a
    href="../../20210628143158.GD656159@rowland.harvard.edu/raw">raw</a>)
      To: i.kononenko
      Cc: Felipe Balbi, Greg Kroah-Hartman, Jens Axboe, openbmc, <a
    href="../../../linux-usb/?t=20210628143344">linux-usb</a>,
        <a
    href="../../../lkml/?t=20210628143344">linux-kernel</a>
    
    On Sun, Jun 27, 2021 at 09:45:07PM +0300, i.kononenko wrote:
    <span
    class="q">&gt; 
    &gt; 
    &gt; On 27.06.2021 17:29, Alan Stern wrote:
    &gt; &gt; Is any of this really needed?  What usage scenarios require
    &gt; &gt; f_mass_storage to emulate a DVD-ROM that couldn&#39;t use f_tcm instead?
    &gt; 
    &gt; I can&#39;t see any impediments to supplement the already existing 
    &gt; implementation of MMC-(2/3) specification of multimedia devices to 
    &gt; represent the DVD/BD features. If the kernel presents the CD-ROM SCSI 
    &gt; commands, why the mass_storage:usb-gadget-function still doesn&#39;t include
    &gt; that for DVD/BD?
    &gt; 
    &gt; Many modern embedded systems (e.g., BMC, OpenBMC) implements their 
    &gt; required features, e.g., Virtual Media Device, which is based on the 
    &gt; usb:gadget:mass-storage. 
    &gt; The purpose of that features is extensive, and their use the mass-storage
    &gt; not only as a cdrom-device.
    &gt; 
    &gt; The required features of such systems might expect image back-end files
    &gt; that size is significant than 2.1Gb, but such medium is not the CD-ROM 
    &gt; device. USB-gadget consumers can incorrectly interpret such device by 
    &gt; loading the wrong driver. I believe that should be the DVD-medium device,
    &gt; at least. 
    </span>
    You should include this information in the patch description, so that 
    people will understand why you wrote the patch.
    
    <span
    class="q">&gt; Additionally, please note the current patch also fixes the incorrect 
    &gt; implementation of retrieving TOC/PMA/ATIP data, which is required for the 
    &gt; CD-ROM. One system might correct works with retrieving first with the 
    &gt; last session together, but for some systems, e.g., OS ESXi, OS Windows, 
    &gt; should retrieving first and last border sessions in separate SCSI-request. 
    </span>
    What&#39;s wrong with the existing implementation?  Are you talking about 
    the do_read_toc function?  The driver only supports one session in any 
    case.
    
    In general, fixes to existing code and additions of new code should go 
    in separate patches.
    
    Alan Stern
    
    <a
    href=#m5fb44d50215ffc5e9b25e79ba275862d87c6d9e5
    id=e5fb44d50215ffc5e9b25e79ba275862d87c6d9e5>^</a> <a
    href="../../20210628143158.GD656159@rowland.harvard.edu/">permalink</a> <a
    href="../../20210628143158.GD656159@rowland.harvard.edu/raw">raw</a> <a
    href="../../20210628143158.GD656159@rowland.harvard.edu/#R">reply</a>	[<a
    href="../../20210628143158.GD656159@rowland.harvard.edu/T/#u"><b>flat</b></a>|<a
    href="../../20210628143158.GD656159@rowland.harvard.edu/t/#u">nested</a>] <a
    href=#r5fb44d50215ffc5e9b25e79ba275862d87c6d9e5>16+ messages in thread</a></pre><hr><pre>end of thread, other threads:[<a
    href="../../?t=20210628143344">~2021-06-28 14:33 UTC</a> | <a
    href="../../">newest</a>]
    
    <b
    id=t>Thread overview:</b> 16+ messages (download: <a
    href="../t.mbox.gz">mbox.gz</a> follow: <a
    href="../t.atom">Atom feed</a>
    -- links below jump to the message on this page --
         [not found] &lt;<a
    href="../../20210626211820.107310-1-i.kononenko@yadro.com/"
    id=r230904767ba2e4c04656f812a82f44b3b82ed27b>20210626211820.107310-1-i.kononenko@yadro.com</a>&gt;
    2021-06-26 21:18 ` <a
    href="#ma15d1b956bb4d021019ecfe176f738e38de1c946"
    id=ra15d1b956bb4d021019ecfe176f738e38de1c946>[PATCH 1/6] usb:gadget:mass-storage: Improve the signature of SCSI handler function</a> Igor Kononenko
    2021-06-27 14:18   ` <a
    href="#mdf9a72eef529aca328a560f9bb4d1ed0af2f5445"
    id=rdf9a72eef529aca328a560f9bb4d1ed0af2f5445>Alan Stern</a>
         [not found]     ` &lt;<a
    href="../../ded6e647-6dd9-ebd0-0ea5-b20e113bf57f@yadro.com/"
    id=r83eeba2a1d348b1b8789a1a1c30e0e4ac1bb1306>ded6e647-6dd9-ebd0-0ea5-b20e113bf57f@yadro.com</a>&gt;
    2021-06-27 16:39       ` <a
    href="#m2ae63575e3b9fca8021a07688446713c75ed0660"
    id=r2ae63575e3b9fca8021a07688446713c75ed0660>Alan Stern</a>
    2021-06-26 21:18 ` <a
    href="#ma4dcc8b46e33a8365a8dca614cab4b78501d241c"
    id=ra4dcc8b46e33a8365a8dca614cab4b78501d241c>[PATCH 2/6] usb:gadget:mass-storage: refactoring the SCSI command handling</a> Igor Kononenko
    2021-06-26 23:29   ` <a
    href="#maaed19c5d26b1f62307d2d9d1215506946eab6bb"
    id=raaed19c5d26b1f62307d2d9d1215506946eab6bb>kernel test robot</a>
    2021-06-27 14:23   ` <a
    href="#m4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6"
    id=r4ff5c63d0b5dd5b2a92bb856a33e05043a69aff6>Alan Stern</a>
         [not found]     ` &lt;<a
    href="../../bc8059b1-0f56-fc3b-6ec8-0bf1043fc9e5@yadro.com/"
    id=rf74b6d8e32965105d0fbbe7249d36d7839ae8d67>bc8059b1-0f56-fc3b-6ec8-0bf1043fc9e5@yadro.com</a>&gt;
    2021-06-28  1:06       ` <a
    href="#mcce16221ad9624292ca75bc6c86a0cc8338f1c04"
    id=rcce16221ad9624292ca75bc6c86a0cc8338f1c04>Alan Stern</a>
    2021-06-26 21:18 ` <a
    href="#m992ff2558771731a4569b5f8b060a9e264f524d1"
    id=r992ff2558771731a4569b5f8b060a9e264f524d1>[PATCH 3/6] fms: Add TOC/PMA/ATIP DVD-ROM capabilities</a> Igor Kononenko
    2021-06-27 14:29   ` <a
    href="#m35fd048e76c49d9594d614700b86a72f47f5ee9f"
    id=r35fd048e76c49d9594d614700b86a72f47f5ee9f>Alan Stern</a>
         [not found]     ` &lt;<a
    href="../../3f9c6e4a-18b7-db11-8b23-f0473a649d06@yadro.com/"
    id=r683401630a462c7816db0bd6c4dbd099bf9e5e17>3f9c6e4a-18b7-db11-8b23-f0473a649d06@yadro.com</a>&gt;
    2021-06-28 14:31       ` <a
    href="#m5fb44d50215ffc5e9b25e79ba275862d87c6d9e5"
    id=r5fb44d50215ffc5e9b25e79ba275862d87c6d9e5>Alan Stern</a>
    2021-06-26 21:18 ` <a
    href="#m01c73ecd2cd3cae217ec69ffe5b54823285cca9e"
    id=r01c73ecd2cd3cae217ec69ffe5b54823285cca9e>[PATCH 4/6] fms: Support the DVD/BD images size over 2.1Gb</a> Igor Kononenko
    2021-06-26 21:18 ` <a
    href="#md657bf4dd0d02f809976e2561e2c45855edcc57d"
    id=rd657bf4dd0d02f809976e2561e2c45855edcc57d>[PATCH 5/6] FMS: Add the SCSI Get Configuration command</a> Igor Kononenko
    2021-06-27  0:44   ` <a
    href="#m31ec12223279c2669d001a846804b3ce28dda048"
    id=r31ec12223279c2669d001a846804b3ce28dda048>kernel test robot</a>
    2021-06-27  4:42   ` <a
    href="#md17f3ece942d5fa5c6d04d837a76c9938262a044"
    id=rd17f3ece942d5fa5c6d04d837a76c9938262a044>kernel test robot</a>
    2021-06-28  9:53   ` <a
    href="#mf92cecbdbd7f078aafb77c93f35e3f89b1b3525f"
    id=rf92cecbdbd7f078aafb77c93f35e3f89b1b3525f>Christoph Hellwig</a>
    2021-06-26 21:18 ` <a
    href="#mf9201ae82cadb63aa148811fdeae78d3d4c1fa16"
    id=rf9201ae82cadb63aa148811fdeae78d3d4c1fa16>[PATCH 6/6] FMS: Add SCSI Read Disc Information command</a> Igor Kononenko
    </pre><hr><pre>This is a public inbox, see <a
    href="../../_/text/mirror/">mirroring instructions</a>
    for how to clone and mirror all data and code used for this inbox;
    as well as URLs for NNTP newsgroup(s).</pre></body></html>